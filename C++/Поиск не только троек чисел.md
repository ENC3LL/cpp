# Поиск не только троек чисел

### КРАТКИЙ ГИД ПО РАСШИРЕНИЮ АЛГОРИТМА

### ОСНОВНОЙ ПРИНЦИП:
**Фиксируем (k-2) элемента, для последних двух используем два указателя**

---

## 1. Для ПАР (2 числа)
```cpp
vector<vector<int>> twoSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    int left = 0, right = nums.size() - 1;
    
    while(left < right) {
        int sum = nums[left] + nums[right];
        if(sum == target) {
            result.push_back({nums[left], nums[right]});
            left++; right--;
            // пропускаем дубликаты
            while(left < right && nums[left] == nums[left-1]) left++;
            while(left < right && nums[right] == nums[right+1]) right--;
        }
        else if(sum < target) left++;
        else right--;
    }
    return result;
}
```

---

## 2. Для ТРОЕК (3 числа) - уже знаем
```cpp
vector<vector<int>> threeSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    
    for(int i = 0; i < nums.size() - 2; i++) {
        if(i > 0 && nums[i] == nums[i-1]) continue; // пропускаем дубликаты
        
        int left = i + 1, right = nums.size() - 1;
        while(left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if(sum == target) {
                result.push_back({nums[i], nums[left], nums[right]});
                left++; right--;
                while(left < right && nums[left] == nums[left-1]) left++;
                while(left < right && nums[right] == nums[right+1]) right--;
            }
            else if(sum < target) left++;
            else right--;
        }
    }
    return result;
}
```

---

## 3. Для ЧЕТВЕРОК (4 числа)
```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    
    for(int i = 0; i < nums.size() - 3; i++) {
        if(i > 0 && nums[i] == nums[i-1]) continue; // пропускаем дубликаты
        
        for(int j = i + 1; j < nums.size() - 2; j++) {
            if(j > i + 1 && nums[j] == nums[j-1]) continue; // пропускаем дубликаты
            
            int left = j + 1, right = nums.size() - 1;
            while(left < right) {
                int sum = nums[i] + nums[j] + nums[left] + nums[right];
                if(sum == target) {
                    result.push_back({nums[i], nums[j], nums[left], nums[right]});
                    left++; right--;
                    while(left < right && nums[left] == nums[left-1]) left++;
                    while(left < right && nums[right] == nums[right+1]) right--;
                }
                else if(sum < target) left++;
                else right--;
            }
        }
    }
    return result;
}
```

---

## 4. УНИВЕРСАЛЬНАЯ ФОРМУЛА

### Для k чисел:
1. **Фиксируем первые (k-2) элементов** через вложенные циклы
2. **Для последних двух** используем алгоритм двух указателей
3. **Границы циклов:**
   - 1-й цикл: `0 → n-k`
   - 2-й цикл: `i+1 → n-(k-1)`  
   - 3-й цикл: `j+1 → n-(k-2)`
   - ...
   - Последние два: `left` и `right`

### Шаблон:
```cpp
vector<vector<int>> kSum(vector<int>& nums, int target, int k) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    
    // Рекурсивно/итеративно добавляем циклы в зависимости от k
    // Для k=4: 2 цикла + два указателя
    // Для k=5: 3 цикла + два указателя
    // И т.д.
    
    return result;
}
```

---

## 5. БЫСТРАЯ ШПАРГАЛКА

| Количество чисел | Структура алгоритма |
|------------------|---------------------|
| **2 числа** | Два указателя |
| **3 числа** | 1 цикл + два указателя |
| **4 числа** | 2 цикла + два указателя |
| **5 чисел** | 3 цикла + два указателя |
| **k чисел** | (k-2) цикла + два указателя |

**Золотое правило:** Всегда начинать с `sort()` и обрабатывать дубликаты в каждом цикле!