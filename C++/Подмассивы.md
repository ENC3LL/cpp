# Подмассивы

## Раздел 1. Основы: Поиск *одиночных* элементов

Это самый базовый уровень: найти *один* конкретный элемент или элемент, отвечающий условию. Все это живет в `<algorithm>`.

### `std::find`

Ищет *первое* вхождение *конкретного значения*.

```C++
#include <iostream>
#include <vector>
#include <algorithm> // <-- Тут все основное

using namespace std;

int main() {
    vector<int> v = {10, 20, 30, 40, 50};
    int value_to_find = 30;

    // Ищем значение 30 в векторе v
    auto it = find(v.begin(), v.end(), value_to_find);

    if (it != v.end()) {
        // Нашли! 'it' - это итератор (указатель) на найденный элемент
        cout << "Значение " << *it << " найдено!" << endl;
        // Как обработать: можем получить индекс
        cout << "Индекс: " << distance(v.begin(), it) << endl; // Выведет 2
    } else {
        // Не нашли! 'it' равен v.end()
        cout << "Значение " << value_to_find << " не найдено." << endl;
    }
    return 0;
}

```



### `std::find_if` (для букв, цифр, четных и т.д.)

Это **супер-важный** алгоритм. Он ищет *первый* элемент, который удовлетворяет *условию* (предикату). Это идеально для твоих задач "поиск букв, цифр".

Условие задается через *лямбда-функцию* `[] (int n) { ... }`.

```C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cctype> // <-- Для isdigit, isalpha

using namespace std;

int main() {
    // --- Задача: Найти первую цифру в строке ---
    string s = "Hello123World";

    auto it_digit = find_if(s.begin(), s.end(), ::isdigit); // ::isdigit из <cctype>

    if (it_digit != s.end()) {
        cout << "Первая цифра: '" << *it_digit << "'" << endl; // Выведет '1'
        cout << "По индексу: " << distance(s.begin(), it_digit) << endl; // Выведет 5
    }

    // --- Задача: Найти первое четное число в векторе ---
    vector<int> nums = {1, 3, 5, 8, 10, 11};

    // Используем лямбда-функцию как условие
    auto it_even = find_if(nums.begin(), nums.end(), [] (int n) {
        return (n % 2) == 0; // Условие: "число четное"
    });

    if (it_even != nums.end()) {
        cout << "Первое четное число: " << *it_even << endl; // Выведет 8
    }
    
    // --- Задача: Найти первую букву НЕ в нижнем регистре ---
    // (для этого есть find_if_not)
    string mix = "abcDEF";
    auto it_not_lower = find_if_not(mix.begin(), mix.end(), ::islower);
    
    if (it_not_lower != mix.end()) {
        cout << "Первый символ НЕ в нижнем регистре: " << *it_not_lower << endl; // D
    }
    
    return 0;
}

```



## Раздел 2. Поиск *подпоследовательностей*

Здесь мы ищем "кусок" внутри "целого".



### `std::search` (поиск "иголки в стоге")

Это то, что мы обсуждали. Ищет *конкретную* непрерывную последовательность.

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> haystack = {1, 2, 3, 4, 5, 1, 2, 3};
    vector<int> needle = {1, 2, 3};

    auto it = search(haystack.begin(), haystack.end(), // Где ищем
                     needle.begin(), needle.end());   // Что ищем

    if (it != haystack.end()) {
        cout << "Подмассив {1, 2, 3} найден!" << endl;
        cout << "Начинается с индекса: " << distance(haystack.begin(), it) << endl; // 0
    }
    
    // --- Задача: Найти *все* вхождения ---
    cout << "Поиск всех вхождений:" << endl;
    auto search_start = haystack.begin();
    while (true) {
        auto result = search(search_start, haystack.end(), 
                             needle.begin(), needle.end());
        
        if (result == haystack.end()) {
            break; // Больше нет, выходим
        }

        cout << "  Найдено на индексе: " << distance(haystack.begin(), result) << endl;
        
        // ВАЖНО: следующий поиск начинаем *после* найденного
        search_start = result + 1;
    }
    // Вывод:
    // Найдено на индексе: 0
    // Найдено на индексе: 5
    
    return 0;
}

```



### `std::find_first_of`

Ищет первый элемент из haystack, который равен любому элементу из needle.

Задача: Найти первый гласный в строке.

```C++
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
    string text = "Hello World";
    string vowels = "aeiouAEIOU"; // Наша "иголка" - это *набор* символов

    auto it = find_first_of(text.begin(), text.end(),   // Где ищем
                            vowels.begin(), vowels.end()); // *Любой* из этих

    if (it != text.end()) {
        cout << "Первый гласный символ: " << *it << endl; // Выведет 'e'
    }
    return 0;
}

```



### `std::search_n`

Ищет N одинаковых элементов подряд.

Задача: Найти три пятерки ({5, 5, 5}) подряд.

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> v = {1, 2, 5, 5, 4, 5, 5, 5, 9};
    
    // Ищем:   3 (N) раза
    // Значение: 5
    auto it = search_n(v.begin(), v.end(), 3, 5);

    if (it != v.end()) {
        cout << "Найдено 3 пятерки подряд, начиная с индекса: " 
             << distance(v.begin(), it) << endl; // Выведет 5
    }
    return 0;
}

```



## Раздел 3. Поиск в *отсортированных* данных

Если твой массив/вектор **отсортирован**, НИКОГДА не используй `std::find`. Используй бинарный поиск. Он работает за $O(\log N)$ (почти мгновенно) вместо $O(N)$ (медленно).



### `std::binary_search`

Просто отвечает "да" или "нет".

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    // ВАЖНО: данные должны быть отсортированы!
    vector<int> sorted_v = {10, 20, 30, 40, 50};
    
    if (binary_search(sorted_v.begin(), sorted_v.end(), 30)) {
        cout << "30 есть в векторе." << endl;
    }
    
    if (!binary_search(sorted_v.begin(), sorted_v.end(), 35)) {
        cout << "35 нет в векторе." << endl;
    }
    return 0;
}

```



### `std::lower_bound` и `std::upper_bound`

Это самые мощные инструменты.

* `lower_bound`: Находит *первый* элемент, который **не меньше** (>=) заданного.
* `upper_bound`: Находит *первый* элемент, который **строго больше** (>) заданного.

**Задача:** Найти *диапазон* всех элементов, равных 40.

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> v = {10, 20, 40, 40, 40, 50, 60};
    
    // Ищем первый элемент >= 40
    auto lower = lower_bound(v.begin(), v.end(), 40);
    
    // Ищем первый элемент > 40
    auto upper = upper_bound(v.begin(), v.end(), 40);

    if (lower != v.end() && *lower == 40) {
        cout << "Элементы '40' найдены." << endl;
        cout << "Начинаются с индекса: " << distance(v.begin(), lower) << endl; // 2
        cout << "Заканчиваются до индекса: " << distance(v.begin(), upper) << endl; // 5
        
        cout << "Количество элементов '40': " << distance(lower, upper) << endl; // 3
        
        // "Как обработать" - можем пройтись по всем:
        cout << "Все найденные '40': ";
        for (auto it = lower; it != upper; ++it) {
            cout << *it << " "; // 40 40 40
        }
        cout << endl;

    } else {
        cout << "Элемент 40 не найден." << endl;
    }
    return 0;
}

```



## Раздел 4. Специальные методы `std::string`

У `std::string` (в `<string>`) есть свои, более удобные методы, которые возвращают *индекс* (`size_t`), а не итератор. Если не нашли — возвращают `string::npos`.

```C++
#include <iostream>
#include <string>

using namespace std;

int main() {
    string text = "this is a test string for test";
    string sub = "test";

    // --- find: поиск первого вхождения ---
    size_t pos = text.find(sub);
    if (pos != string::npos) {
        cout << "'test' найден на позиции: " << pos << endl; // 10
    }

    // --- rfind: поиск *последнего* вхождения (с_к_о_н_ц_а) ---
    pos = text.rfind(sub);
    if (pos != string::npos) {
        cout << "'test' (последний) найден на позиции: " << pos << endl; // 27
    }

    // --- find_first_of: найти *любой* символ из набора (как std::find_first_of) ---
    // Задача: Найти первый знак препинания
    string s = "Hello, world!";
    string punctuation = ",.!?";
    
    pos = s.find_first_of(punctuation);
    if (pos != string::npos) {
        cout << "Первый знак препинания '" << s[pos] << "' на позиции: " << pos << endl; // ',' на 5
    }

    // --- find_first_not_of: найти первый символ *НЕ* из набора ---
    // Задача: Пропустить пробелы в начале строки (trim left)
    string dirty = "   some data";
    string whitespace = " \t\n"; // пробел, таб, новая строка
    
    pos = dirty.find_first_not_of(whitespace);
    if (pos != string::npos) {
        cout << "Данные начинаются с индекса: " << pos << endl; // 3
        // "Как обработать":
        string clean = dirty.substr(pos);
        cout << "Очищенная строка: '" << clean << "'" << endl; // 'some data'
    }
    return 0;
}

```



## Раздел 5. Классические Задачи (твои "задания")

А теперь самое интересное — задачи, которые не решаются одним вызовом функции, а требуют *алгоритма*.



### Задача 1: Поиск подмассива с максимальной суммой (Алгоритм Кадане)

Это твой вопрос: "поиск самого большого непрерывного куска с максимальным значением" (обычно имеется в виду *сумма*).

**Идея:** Мы идем по массиву и накапливаем "текущую сумму" (`current_sum`).

1. `max_sum` — хранит лучший результат, который мы *уже* видели.
2. `current_sum` — хранит сумму подмассива, который *заканчивается* на текущем элементе.
3. На каждом шаге мы решаем: нам выгоднее *продолжить* старый подмассив (добавив `vec[i]`) или *начать новый* (просто взяв `vec[i]`)? Это `current_sum = max(vec[i], current_sum + vec[i])`.
4. Если `current_sum` стал больше `max_sum`, обновляем `max_sum`.

```C++
#include <iostream>
#include <vector>
#include <algorithm> // Для max
#include <numeric>   // Для numeric_limits

using namespace std;

int main() {
    //                                     Вот этот кусок: {4, -1, 2, 1} = 6
    vector<int> v = {-2, 1, -3, 4, -1, 2, 1, -5, 4};

    if (v.empty()) {
        cout << "Массив пуст!" << endl;
        return 0;
    }

    int max_sum = v[0]; // Глобальный максимум (пока что)
    int current_sum = v[0]; // Максимум, заканчивающийся *здесь*

    // Начинаем со второго элемента (i=1)
    for (size_t i = 1; i < v.size(); ++i) {
        // Что выгоднее: начать новый подмассив с v[i]
        // ИЛИ прибавить v[i] к старому?
        current_sum = max(v[i], current_sum + v[i]);
        
        // Не забываем обновить глобальный максимум
        max_sum = max(max_sum, current_sum);
    }

    cout << "Максимальная сумма непрерывного подмассива: " << max_sum << endl; // 6
    
    // Случай с одними отрицательными
    vector<int> v_neg = {-10, -5, -3, -20};
    // (Алгоритм корректно найдет -3)
    
    max_sum = v_neg[0];
    current_sum = v_neg[0];
    for (size_t i = 1; i < v_neg.size(); ++i) {
        current_sum = max(v_neg[i], current_sum + v_neg[i]);
        max_sum = max(max_sum, current_sum);
    }
    cout << "Максимум для {-10, -5, -3, -20}: " << max_sum << endl; // -3
    
    return 0;
}

```



### Задача 2: Поиск самого длинного *непрерывного* куска (Run-Length)

Задача: Найти самую длинную последовательность из одинаковых элементов.

Например, в {1, 2, 2, 2, 3, 3, 1, 1, 1, 1} — это четыре единицы.

**Идея:** Обычный цикл. Мы считаем `current_length` и храним `max_length`. Как только элемент меняется — сбрасываем `current_length` в 1.

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> v = {1, 2, 2, 2, 3, 3, 1, 1, 1, 1, 5};

    if (v.empty()) return 0;

    int max_length = 0;
    int max_value = v[0]; // Значение самого длинного куска
    
    int current_length = 0;

    // v.push_back(v.back() + 1); // "Страж" - хак, чтоб обработать конец
    // Но лучше сделаем по-честному

    for (size_t i = 0; i < v.size(); ++i) {
        if (i == 0 || v[i] == v[i-1]) {
            // Либо первый элемент, либо продолжаем последовательность
            current_length++;
        } else {
            // Последовательность прервалась, v[i] != v[i-1]
            // Сбрасываем счетчик
            current_length = 1;
        }

        // После каждого шага проверяем, не побили ли мы рекорд
        if (current_length > max_length) {
            max_length = current_length;
            max_value = v[i];
        }
    }

    cout << "Самый длинный кусок: " << max_length << " раз" << endl;
    cout << "Состоял из: " << max_value << endl;
    
    return 0;
}

```



### Задача 3: Проверка *свойств* (all_of, any_of, none_of)

Иногда нужно не *найти* элемент, а *проверить*, все ли/хоть один/ни один элемент не отвечают условию.

```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cctype>

using namespace std;

int main() {
    vector<int> v = {2, 4, 6, 8, 10};
    string s = "Hello123";
    string only_digits = "12345";

    // --- all_of ---
    // Все ли элементы в 'v' четные?
    bool all_even = all_of(v.begin(), v.end(), [] (int n) { return n % 2 == 0; });
    if (all_even) {
        cout << "v: Все элементы четные." << endl;
    }

    // Все ли символы в 's' - цифры?
    bool s_all_digits = all_of(s.begin(), s.end(), ::isdigit);
    if (!s_all_digits) {
        cout << "s: НЕ все символы - цифры." << endl;
    }
    
    // --- any_of ---
    // Есть ли в 's' хоть одна цифра?
    bool s_has_digit = any_of(s.begin(), s.end(), ::isdigit);
    if (s_has_digit) {
        cout << "s: Есть хотя бы одна цифра." << endl;
    }
    
    // --- none_of ---
    // Правда ли, что в 'only_digits' нет букв?
    bool no_letters = none_of(only_digits.begin(), only_digits.end(), ::isalpha);
    if (no_letters) {
        cout << "only_digits: Нет ни одной буквы." << endl;
    }

    return 0;
}

```




