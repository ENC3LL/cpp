# Сортировка, поиск и другие алгоритмы

Для сложных операций с векторами используется библиотека `<algorithm>`. Она содержит множество готовых функций.

```c++
#include <iostream>
#include <vector>
#include <algorithm> // для sort, find, reverse
#include <numeric>   // для accumulate

int main() {
    std::vector<int> vec = {50, 20, 80, 10, 40, 20};

    // --- Сортировка ---
    std::sort(vec.begin(), vec.end()); // Сортировка по возрастанию
    std::cout << "Отсортированный вектор: ";
    for (int el : vec) std::cout << el << " ";
    std::cout << std::endl;

    // --- Поиск элемента ---
    int value_to_find;
    std::cout << "Введите значение для поиска: ";
    std::cin >> value_to_find;
    auto it = std::find(vec.begin(), vec.end(), value_to_find);

    if (it != vec.end()) {
        // distance вычисляет расстояние (индекс) от начала до итератора
        long long index = std::distance(vec.begin(), it);
        std::cout << "Элемент " << value_to_find << " найден на позиции " << index << std::endl;
    } else {
        std::cout << "Элемент " << value_to_find << " не найден." << std::endl;
    }

    // --- Реверс (переворот) вектора ---
    std::reverse(vec.begin(), vec.end());
    std::cout << "Перевернутый вектор: ";
    for (int el : vec) std::cout << el << " ";
    std::cout << std::endl;

    // --- Подсчет суммы элементов ---
    int sum = std::accumulate(vec.begin(), vec.end(), 0); // 0 - начальное значение суммы
    std::cout << "Сумма всех элементов: " << sum << std::endl;
    
    // --- Поиск минимального и максимального элемента ---
    auto min_it = std::min_element(vec.begin(), vec.end());
    auto max_it = std::max_element(vec.begin(), vec.end());
    std::cout << "Минимальный элемент: " << *min_it << std::endl;
    std::cout << "Максимальный элемент: " << *max_it << std::endl;

    return 0;
}
```