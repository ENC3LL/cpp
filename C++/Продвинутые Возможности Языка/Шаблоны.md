# Шаблоны

## 1. Шаблоны функций (Function Templates)

* **Пояснение:** "Рецепт" для создания функций. Компилятор автоматически генерирует версии для разных типов данных.
* **Код:**
```c++
#include <iostream>
#include <string>

template <typename T>
T get_max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Max of 3 and 7: " << get_max(3, 7) << std::endl;
    std::cout << "Max of 3.14 and 2.71: " << get_max(3.14, 2.71) << std::endl;
    std::cout << "Max of 'hello' and 'world': " << 
        get_max(std::string("hello"), std::string("world")) << std::endl;
    
    // Явное указание типа
    std::cout << "Max of 3 and 7.5: " << get_max<double>(3, 7.5) << std::endl;
    
    return 0;
}
```
* **Разбор кода:** `template <typename T>` объявляет тип-заполнитель. Компилятор создает конкретные функции для `int`, `double` и `std::string`.

---

## 2. Шаблоны классов (Class Templates)

* **Пояснение:** "Рецепты" для создания обобщенных классов. Основа стандартных контейнеров.
* **Код:**
```c++
#include <iostream>
#include <stdexcept>

template <typename T, int Size>
class StaticArray {
private:
    T m_array[Size];
public:
    T& operator[](int index) {
        if (index < 0 || index >= Size) {
            throw std::out_of_range("Index out of range!");
        }
        return m_array[index];
    }
};

int main() {
    StaticArray<int, 10> intArray;
    intArray[0] = 100;
    
    StaticArray<std::string, 5> stringArray;
    stringArray[0] = "Hello";
    
    std::cout << intArray[0] << std::endl;
    std::cout << stringArray[0] << std::endl;
    
    return 0;
}
```
* **Разбор кода:** Класс может хранить массив любого типа `T` и размера `Size`. Нетиповой параметр `Size` задается на этапе компиляции.

---

## 3. Специализация шаблонов (Template Specialization)

* **Пояснение:** Создание особой реализации шаблона для конкретного типа.
* **Код:**
```c++
#include <iostream>
#include <vector>

template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}

template <>
void print<std::vector<int>>(const std::vector<int>& vec) {
    std::cout << "Printing vector<int>: ";
    for (int val : vec) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
}

int main() {
    int a = 5;
    print(a); // Общий шаблон

    std::vector<int> my_vec = {1, 2, 3};
    print(my_vec); // Специализированная версия
    
    return 0;
}
```
* **Разбор кода:** Для `std::vector<int>` используется специальная версия, форматирующая вывод.

---

## 4. Вариативные шаблоны (Variadic Templates) (C++11)

* **Пояснение:** Шаблоны с переменным числом аргументов.
* **Код:**
```c++
#include <iostream>

void print_all() {
    std::cout << std::endl;
}

template <typename T, typename... Args>
void print_all(T first, Args... args) {
    std::cout << first << " ";
    print_all(args...);
}

int main() {
    print_all("Hello", 42, 3.14, 'c');
    print_all(1, 2, 3);
    
    return 0;
}
```
* **Разбор кода:** `typename... Args` объявляет пакет параметров. Функция рекурсивно обрабатывает аргументы.

---

## 5. Вывод типов для шаблонов классов (CTAD, C++17)

* **Пояснение:** Автоматический вывод типов шаблонных классов из аргументов конструктора.
* **Код:**
```c++
#include <vector>
#include <utility>

int main() {
    // C++17 - автоматический вывод типов
    std::vector v2 = {1, 2, 3}; // vector<int>
    std::pair p2(42, "hello");  // pair<int, const char*>
    
    return 0;
}
```
* **Разбор кода:** Компилятор анализирует типы аргументов и подставляет шаблонные параметры.

---

## 6. Концепты (Concepts) (C++20)

* **Пояснение:** Ограничения на типы для шаблонных параметров. Улучшает диагностику ошибок.
* **Код:**
```c++
#include <iostream>
#include <concepts>

template <typename T>
concept Integral = std::is_integral_v<T>;

template <Integral T>
void process_number(T num) {
    std::cout << "Processing integral number: " << num << std::endl;
}

void process_number2(Integral auto num) {
    std::cout << "Processing integral number (syntax 2): " << num << std::endl;
}

int main() {
    process_number(42);      // OK
    process_number('a');     // OK
    // process_number(3.14); // Ошибка: double не удовлетворяет концепту
    
    return 0;
}
```
* **Разбор кода:** Концепт `Integral` ограничивает допустимые типы. Ошибки компиляции становятся понятнее.

---

## 7. Шаблонные параметры по умолчанию

* **Пояснение:** Параметры шаблонов могут иметь значения по умолчанию.
* **Код:**
```c++
#include <iostream>

template <typename T = int, int Size = 10>
class FixedArray {
private:
    T m_data[Size];
public:
    void set(int index, const T& value) {
        m_data[index] = value;
    }
    T get(int index) const {
        return m_data[index];
    }
};

int main() {
    FixedArray<> arr1; // Использует параметры по умолчанию: int, 10
    FixedArray<double, 5> arr2; // Явное указание
    
    arr1.set(0, 100);
    arr2.set(0, 3.14);

    std::cout << arr1.get(0) << std::endl;
    std::cout << arr2.get(0) << std::endl;

    return 0;
}
```

---

## 8. Шаблонные члены класса

* **Пояснение:** Отдельные члены класса могут быть шаблонными, даже если сам класс не шаблонный.
* **Код:**
```c++
#include <iostream>

class Printer {
public:
    template <typename T>
    void print(const T& value) {
        std::cout << value << std::endl;
    }
};

int main() {
    Printer p;
    p.print(42);
    p.print("Hello");
    return 0;
}
```

---

## 9. Шаблонные псевдонимы (Alias Templates) (C++11)

* **Пояснение:** Создание псевдонимов для шаблонных типов.
* **Код:**
```c++
#include <vector>
#include <map>
#include <string>

template <typename T>
using Vec = std::vector<T>;

template <typename Value>
using StringMap = std::map<std::string, Value>;

int main() {
    Vec<int> numbers; // std::vector<int>
    StringMap<int> ages; // std::map<std::string, int>
    
    numbers.push_back(1);
    ages["Alice"] = 30;
    
    return 0;
}
```

---

## 10. Шаблонные переменные (C++14)

* **Пояснение:** Переменные могут быть шаблонными для констант, зависящих от типа.
* **Код:**
```c++
#include <iostream>

template <typename T>
constexpr T pi = T(3.1415926535897932385L);

template <>
constexpr int pi<int> = 3;

int main() {
    std::cout << pi<double> << std::endl; // 3.14159
    std::cout << pi<float> << std::endl;  // 3.14159
    std::cout << pi<int> << std::endl;    // 3
    return 0;
}
```

---

## 11. SFINAE и `std::enable_if`

* **Пояснение:** Условная компиляция шаблонов до C++20.
* **Код:**
```c++
#include <iostream>
#include <type_traits>

template <typename T>
std::enable_if_t<std::is_integral_v<T>, T> 
add(T a, T b) {
    std::cout << "Integral version" << std::endl;
    return a + b;
}

template <typename T>
std::enable_if_t<std::is_floating_point_v<T>, T> 
add(T a, T b) {
    std::cout << "Floating point version" << std::endl;
    return a + b;
}

int main() {
    add(1, 2);       // Целочисленная версия
    add(1.0, 2.0);   // Версия для плавающей точки
    return 0;
}
```

---

## 12. `if constexpr` (C++17)

* **Пояснение:** Условная компиляция на этапе компиляции.
* **Код:**
```c++
#include <iostream>
#include <type_traits>

template <typename T>
void print_type_info(const T& value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integral type: " << value << std::endl;
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Floating point type: " << value << std::endl;
    } else {
        std::cout << "Other type: " << value << std::endl;
    }
}

int main() {
    print_type_info(42);        // Integral
    print_type_info(3.14);      // Floating point
    print_type_info("Hello");   // Other
    return 0;
}
```

---

## 13. Частичная специализация

* **Пояснение:** Специализация для части шаблонных параметров.
* **Код:**
```c++
#include <iostream>

template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;
    void print() { std::cout << "General Pair" << std::endl; }
};

template <typename T>
class Pair<T, T> { // Частичная специализация для одинаковых типов
public:
    T first, second;
    void print() { std::cout << "Same type Pair" << std::endl; }
};

int main() {
    Pair<int, double> p1;
    Pair<int, int> p2;
    
    p1.print(); // General Pair
    p2.print(); // Same type Pair
    
    return 0;
}
```

## Ключевые выводы

1. **Шаблоны функций** - обобщенные алгоритмы
2. **Шаблоны классов** - обобщенные контейнеры и структуры данных
3. **Специализация** - особое поведение для конкретных типов
4. **Вариативные шаблоны** - работа с переменным числом аргументов
5. **Концепты (C++20)** - современный способ ограничений типов
6. **CTAD (C++17)** - автоматический вывод типов
7. **`if constexpr`** - условная компиляция

Современный C++ делает шаблоны более безопасными и удобными через концепты и улучшенный вывод типов.