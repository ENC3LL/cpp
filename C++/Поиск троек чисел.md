# Поиск троек чисел

## 1. Базовые понятия о векторах

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // для sort()

using namespace std;

int main() {
    // Создание вектора
    vector<int> nums = {2, 7, 11, 15, 3, 1, 8, 4};
    
    // Размер вектора
    int n = nums.size();
    cout << "Размер вектора: " << n << endl;
    
    // Доступ к элементам
    cout << "Первый элемент: " << nums[0] << endl;
    cout << "Второй элемент: " << nums.at(1) << endl;
    
    return 0;
}
```

## 2. Простой перебор (Brute Force) - основа понимания

Прежде чем переходить к оптимизациям, поймем базовый принцип:

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    int target = 0; // будем искать тройки, сумма которых равна 0
    
    cout << "Все тройки с суммой 0 (простой перебор):" << endl;
    
    // Три вложенных цикла - перебираем все возможные комбинации троек
    for(int i = 0; i < nums.size(); i++) {
        for(int j = i + 1; j < nums.size(); j++) {
            for(int k = j + 1; k < nums.size(); k++) {
                if(nums[i] + nums[j] + nums[k] == target) {
                    cout << "[" << nums[i] << ", " << nums[j] << ", " << nums[k] << "]" << endl;
                }
            }
        }
    }
    
    return 0;
}
```

**Проблема:** Сложность O(n³) - очень медленно для больших массивов.

## 3. Алгоритм двух указателей (Two Pointers) - разбор "магии"

### Основная идея:
1. **Сортируем массив** - это ключевой шаг!
2. **Фиксируем первый элемент** тройки
3. **Два указателя** ищут оставшуюся пару в отсортированной части

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    int target = 0;
    
    // Шаг 1: СОРТИРОВКА - без этого алгоритм не работает!
    sort(nums.begin(), nums.end());
    cout << "Отсортированный массив: ";
    for(int num : nums) cout << num << " ";
    cout << endl << endl;
    
    cout << "Тройки с суммой 0 (алгоритм двух указателей):" << endl;
    
    // Шаг 2: Перебираем возможные первые элементы троек
    for(int i = 0; i < nums.size() - 2; i++) { // -2 потому что нужны еще 2 элемента
        
        // Пропускаем дубликаты для первого элемента
        if(i > 0 && nums[i] == nums[i-1]) continue;
        
        // Шаг 3: Настраиваем два указателя
        int left = i + 1;        // следующий после i
        int right = nums.size() - 1; // последний элемент
        
        // Шаг 4: Двигаем указатели пока они не встретятся
        while(left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            
            cout << "Проверяем: nums[" << i << "]=" << nums[i] 
                 << " + nums[" << left << "]=" << nums[left] 
                 << " + nums[" << right << "]=" << nums[right] 
                 << " = " << sum << endl;
            
            if(sum == target) {
                // Нашли нужную тройку!
                cout << ">>> НАШЛИ: [" << nums[i] << ", " << nums[left] << ", " << nums[right] << "]" << endl;
                
                // Перемещаем оба указателя и пропускаем дубликаты
                left++;
                right--;
                
                // Пропускаем одинаковые элементы слева
                while(left < right && nums[left] == nums[left-1]) left++;
                // Пропускаем одинаковые элементы справа  
                while(left < right && nums[right] == nums[right+1]) right--;
            }
            else if(sum < target) {
                // Сумма слишком мала - двигаем ЛЕВЫЙ указатель вправо (увеличиваем сумму)
                cout << "Сумма слишком мала, двигаем LEFT++" << endl;
                left++;
            }
            else {
                // Сумма слишком велика - двигаем ПРАВЫЙ указатель влево (уменьшаем сумму)
                cout << "Сумма слишком велика, двигаем RIGHT--" << endl;
                right--;
            }
        }
    }
    
    return 0;
}
```

## 4. Визуализация работы алгоритма

Для массива `[-4, -1, -1, 0, 1, 2]`:

```
Итерация 1: i=0 (элемент -4)
  left=1 (-1), right=5 (2) → сумма=-3 → маловато → left++
  left=2 (-1), right=5 (2) → сумма=-3 → маловато → left++
  left=3 (0), right=5 (2) → сумма=-2 → маловато → left++
  left=4 (1), right=5 (2) → сумма=-1 → маловато → left++

Итерация 2: i=1 (элемент -1)
  left=2 (-1), right=5 (2) → сумма=0 → НАШЛИ! [-1, -1, 2]
  left=3 (0), right=4 (1) → сумма=0 → НАШЛИ! [-1, 0, 1]

Итерация 3: i=2 (элемент -1) - ПРОПУСК, так как дубликат
...
```

## 5. Универсальная функция для поиска троек

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> findTriplets(vector<int>& nums, int target) {
    vector<vector<int>> result;
    
    // Сортируем массив
    sort(nums.begin(), nums.end());
    
    for(int i = 0; i < nums.size() - 2; i++) {
        // Пропускаем дубликаты
        if(i > 0 && nums[i] == nums[i-1]) continue;
        
        int left = i + 1;
        int right = nums.size() - 1;
        
        while(left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            
            if(sum == target) {
                // Добавляем тройку в результат
                result.push_back({nums[i], nums[left], nums[right]});
                
                // Двигаем оба указателя
                left++;
                right--;
                
                // Пропускаем дубликаты
                while(left < right && nums[left] == nums[left-1]) left++;
                while(left < right && nums[right] == nums[right+1]) right--;
            }
            else if(sum < target) {
                left++;
            }
            else {
                right--;
            }
        }
    }
    
    return result;
}

int main() {
    vector<int> nums = {-1, 0, 1, 2, -1, -4};
    int target = 0;
    
    vector<vector<int>> triplets = findTriplets(nums, target);
    
    cout << "Найдено " << triplets.size() << " троек:" << endl;
    for(const auto& triplet : triplets) {
        cout << "[" << triplet[0] << ", " << triplet[1] << ", " << triplet[2] << "]" << endl;
    }
    
    return 0;
}
```

## 6. Важные тонкости и подводные камни

### Тонкость 1: Почему именно такая проверка дубликатов?
```cpp
if(i > 0 && nums[i] == nums[i-1]) continue;
```
Проверяем с ПРЕДЫДУЩИМ элементом, а не следующим, потому что:
- Мы уже обработали предыдущий элемент
- Если пропускать следующий, можем пропустить valid тройки

### Тонкость 2: Порядок операций при нахождении тройки
```cpp
left++;
right--;
// затем пропускаем дубликаты
```
Сначала двигаем указатели, ПОТОМ пропускаем дубликаты.

### Тонкость 3: Граничные условия
```cpp
for(int i = 0; i < nums.size() - 2; i++)
```
`-2` потому что для тройки нужны как минимум 3 элемента.

## 7. Практические примеры

### Пример: Поиск троек с суммой близкой к заданной

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // для функции sort() - сортировки массива
#include <climits>   // для констант типа INT_MAX, но в этом коде не используется

using namespace std; // используем стандартное пространство имен

// Функция для поиска тройки чисел с суммой, наиболее близкой к target
int threeSumClosest(vector<int>& nums, int target) {
    // Шаг 1: СОРТИРУЕМ массив - это основа алгоритма двух указателей
    // Без сортировки указатели не смогут двигаться логично
    sort(nums.begin(), nums.end());
    
    // Шаг 2: Инициализируем переменную для хранения самой близкой суммы
    // В качестве начального значения берем сумму первых трех элементов
    // Это наша "лучшая на данный момент" тройка
    int closestSum = nums[0] + nums[1] + nums[2];
    
    // Шаг 3: Перебираем все возможные первые элементы тройки
    // i - индекс первого элемента тройки
    // Останавливаемся за 2 элемента до конца, т.к. нужны еще left и right
    for(int i = 0; i < nums.size() - 2; i++) {
        
        // Шаг 4: Настраиваем два указателя:
        // left - следующий элемент после i (второй элемент тройки)
        // right - последний элемент массива (третий элемент тройки)
        int left = i + 1;
        int right = nums.size() - 1;
        
        // Шаг 5: Двигаем указатели пока они не встретятся
        // left и right будут сходиться к центру
        while(left < right) {
            // Вычисляем сумму текущей тройки
            int currentSum = nums[i] + nums[left] + nums[right];
            
            // Шаг 6: Проверяем, не нашли ли мы более близкую сумму
            // abs() - функция модуля, вычисляет "расстояние" до target
            // Если текущая сумма ближе к target, чем наша лучшая, обновляем лучшую
            if(abs(currentSum - target) < abs(closestSum - target)) {
                closestSum = currentSum; // обновляем самую близкую сумму
            }
            
            // Шаг 7: Решаем, какой указатель двигать
            if(currentSum < target) {
                // Сумма слишком мала - нужно УВЕЛИЧИТЬ сумму
                // В отсортированном массиве двигаем ЛЕВЫЙ указатель ВПРАВО
                // (к большим числам) чтобы увеличить сумму
                left++;
            }
            else if(currentSum > target) {
                // Сумма слишком велика - нужно УМЕНЬШИТЬ сумму  
                // В отсортированном массиве двигаем ПРАВЫЙ указатель ВЛЕВО
                // (к меньшим числам) чтобы уменьшить сумму
                right--;
            }
            else {
                // Случай точного совпадения! 
                // currentSum == target - нашли идеальную тройку
                // Можно сразу возвращать результат, т.к. лучше уже не будет
                return currentSum;
            }
            
            // Шаг 8: Цикл продолжается с новыми left/right
            // Указатели будут сходиться пока left < right
        }
        
        // Шаг 9: Переходим к следующему первому элементу (i++)
        // и снова запускаем движение указателей для нового i
    }
    
    // Шаг 10: Возвращаем самую близкую сумму, которую нашли
    // Если не было точного совпадения, вернет наиболее близкую
    return closestSum;
}

int main() {
    // Создаем тестовый массив
    vector<int> nums = {-1, 2, 1, -4};
    int target = 1; // целевая сумма, к которой ищем ближайшую тройку
    
    // Вызываем нашу функцию и сохраняем результат
    int result = threeSumClosest(nums, target);
    
    // Выводим результат
    cout << "Ближайшая сумма к " << target << ": " << result << endl;
    
    return 0;
}
```
