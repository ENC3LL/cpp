# Массивы, Указатели, Ссылки

### Массивы в C++

Массивы - это структуры данных, которые хранят фиксированное количество элементов одного типа в непрерывном блоке памяти.

**C-style Массивы (Raw Arrays)**
* **Пояснение:** Низкоуровневый способ работы с массивами, унаследованный от языка C. Размер должен быть известен на этапе компиляции, не хранят информацию о своем размере.
* **Код:**
```c++
#include <iostream>

int main() {
    // Объявление и инициализация
    int numbers[5] = {10, 20, 30, 40, 50};

    // Доступ к элементу
    std::cout << "Третий элемент: " << numbers[2] << std::endl; // Выведет 30

    // Изменение элемента
    numbers[0] = 5;

    // Итерация по массиву
    for (int i = 0; i < 5; ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
* **Разбор кода:** `int numbers[5]` создает массив на 5 целых чисел. Доступ через `[]`, индексация с 0. Размер фиксирован.

---

**`std::array`**
* **Пояснение:** Современная оболочка над C-style массивами. Знает свой размер, безопасная передача в функции, предотвращает ошибки.
* **Код:**
```c++
#include <iostream>
#include <array>

int main() {
    // Объявление и инициализация
    std::array<int, 5> numbers = {10, 20, 30, 40, 50};

    // Доступ к элементу
    std::cout << "Третий элемент: " << numbers[2] << std::endl;
    std::cout << "Первый элемент (безопасно): " << numbers.at(0) << std::endl;

    // Получение размера
    std::cout << "Размер массива: " << numbers.size() << std::endl;

    // Итерация
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
* **Разбор кода:** `std::array<int, 5>` объявляет массив из 5 целых чисел. `.at(i)` обеспечивает безопасный доступ с проверкой границ.

---

**`std::vector`**
* **Пояснение:** Динамический массив, который может изменять размер во время выполнения. Автоматическое управление памятью.
* **Код:**
```c++
#include <iostream>
#include <vector>

int main() {
    // Объявление пустого вектора
    std::vector<int> numbers = {10, 20, 30};

    // Добавление элементов
    numbers.push_back(40);
    numbers.push_back(50);

    // Доступ к элементу
    std::cout << "Первый элемент: " << numbers[0] << std::endl;

    // Получение размера
    std::cout << "Текущий размер: " << numbers.size() << std::endl;

    // Удаление последнего элемента
    numbers.pop_back();

    // Итерация
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
* **Разбор кода:** `.push_back()` добавляет элемент в конец, `.size()` возвращает количество элементов, `.pop_back()` удаляет последний элемент.

---

### Указатели в C++

Указатель — это переменная, которая хранит адрес в памяти другой переменной.

**"Сырые" Указатели (Raw Pointers)**
* **Пояснение:** Базовый тип указателей из C. Позволяют напрямую работать с памятью, требуют ручного управления.
* **Код:**
```c++
#include <iostream>

int main() {
    int var = 42;
    int* ptr = &var; // ptr хранит адрес переменной var

    std::cout << "Значение var: " << var << std::endl;
    std::cout << "Адрес var: " << &var << std::endl;
    std::cout << "Значение ptr (адрес): " << ptr << std::endl;
    std::cout << "Значение по адресу ptr: " << *ptr << std::endl;

    // Изменение значения var через указатель
    *ptr = 100;
    std::cout << "Новое значение var: " << var << std::endl;

    // Динамическая память
    int* dynamic_ptr = new int(99); // Выделение памяти в куче
    std::cout << "Динамическое значение: " << *dynamic_ptr << std::endl;
    delete dynamic_ptr; // Обязательное освобождение памяти!
    dynamic_ptr = nullptr;

    return 0;
}
```
* **Разбор кода:** `int* ptr` объявляет указатель. `&var` получает адрес, `*ptr` разыменовывает. `new` выделяет память, `delete` освобождает.

---

**Умные Указатели (`std::unique_ptr`)**
* **Пояснение:** Автоматизируют управление памятью. `unique_ptr` гарантирует единоличное владение объектом.
* **Код:**
```c++
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Конструктор MyClass" << std::endl; }
    ~MyClass() { std::cout << "Деструктор MyClass" << std::endl; }
    void greet() { std::cout << "Привет!" << std::endl; }
};

int main() {
    // Создаем unique_ptr
    std::unique_ptr<MyClass> u_ptr = std::make_unique<MyClass>();
    
    u_ptr->greet(); // Доступ к методам через ->

    return 0; // Деструктор MyClass вызывается автоматически
}
```
* **Разбор кода:** `std::make_unique` создает объект и указатель. Память освобождается автоматически при выходе из области видимости.

---

### Ссылки в C++

Ссылка — это псевдоним для уже существующей переменной.

* **Пояснение:** Используются для передачи параметров в функции без копирования и изменения переданных переменных. Должны быть инициализированы при объявлении.
* **Код:**
```c++
#include <iostream>

// Функция принимает параметр по ссылке
void increment(int& value) {
    value++; // Изменяется оригинальная переменная
}

int main() {
    int original = 10;
    int& ref = original; // ref - это другое имя для original

    std::cout << "Original: " << original << std::endl;
    std::cout << "Reference: " << ref << std::endl;

    ref = 20; // Изменяем original через ссылку

    std::cout << "Original после изменения: " << original << std::endl;

    increment(original); // Передаем в функцию без копирования
    std::cout << "Original после функции: " << original << std::endl;

    return 0;
}
```
* **Разбор кода:** `int& ref = original` создает ссылку на `original`. Любое действие с `ref` — действие с `original`. Функция `increment` изменяет оригинальную переменную.