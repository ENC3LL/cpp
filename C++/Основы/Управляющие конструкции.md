# Управляющие конструкции


### Конструкции выбора (Ветвления)

**`if`**
* **Пояснение:** Выполняет блок кода, если заданное условие истинно (`true`). Используется для выполнения кода только при определённом условии.
* **Код:**
```c++
int a = 10;
if (a > 5) {
    std::cout << "a больше 5" << std::endl;
}
```
* **Разбор кода:** Программа проверяет, больше ли переменная `a` пяти. Так как `10 > 5` — это истина, код внутри фигурных скобок выполняется.

---

**`if-else`**
* **Пояснение:** Выполняет один блок кода, если условие истинно, и другой блок, если оно ложно (`false`). Используется для выбора одного из двух вариантов действий.
* **Код:**
```c++
int a = 3;
if (a > 5) {
    std::cout << "a больше 5" << std::endl;
} else {
    std::cout << "a не больше 5" << std::endl;
}
```
* **Разбор кода:** Условие `a > 5` (3 > 5) ложно. Поэтому выполняется блок кода после `else`.

---

**`if-else if-else`**
* **Пояснение:** Проверяет последовательно несколько условий. Используется для создания цепочки проверок, когда нужно выбрать один из многих вариантов.
* **Код:**
```c++
int a = 5;
if (a > 5) {
    std::cout << "a больше 5" << std::endl;
} else if (a < 5) {
    std::cout << "a меньше 5" << std::endl;
} else {
    std::cout << "a равно 5" << std::endl;
}
```
* **Разбор кода:** Первое условие (`a > 5`) ложно. Проверяется второе (`a < 5`), оно тоже ложно. В итоге выполняется блок `else`.

---

**`switch`**
* **Пояснение:** Сравнивает значение переменной с несколькими константными значениями (`case`). Удобная замена громоздким `if-else if` конструкциям.
* **Код:**
```c++
int option = 2;
switch (option) {
    case 1:
        std::cout << "Выбран вариант 1" << std::endl;
        break;
    case 2:
        std::cout << "Выбран вариант 2" << std::endl;
        break;
    default:
        std::cout << "Неизвестный вариант" << std::endl;
        break;
}
```
* **Разбор кода:** Значение `option` равно 2. Программа переходит к `case 2` и выполняет соответствующий код. Оператор `break` необходим для выхода из `switch`.

---

**Тернарный оператор `?:`**
* **Пояснение:** Компактная форма `if-else`. Используется для краткой записи простых условных выражений, обычно для присваивания значения.
* **Код:**
```c++
int a = 10;
int b = 5;
int max = (a > b) ? a : b; // max будет равно a
std::cout << "Максимальное значение: " << max << std::endl;
```
* **Разбор кода:** Условие `a > b` истинно, поэтому выражению `max` присваивается значение `a` (то, что стоит до двоеточия).

---

### Циклические конструкции (Циклы)

**`while`**
* **Пояснение:** Выполняет блок кода, *пока* условие истинно. Условие проверяется **перед** каждой итерацией. Используется когда количество повторений заранее неизвестно.
* **Код:**
```c++
int i = 0;
while (i < 3) {
    std::cout << i << std::endl;
    i++; // Важно изменять переменную, чтобы цикл не стал бесконечным
}
```
* **Разбор кода:** Цикл выполняется, пока `i` меньше 3. На каждой итерации значение `i` выводится и увеличивается на 1.

---

**`do-while`**
* **Пояснение:** Сначала выполняет блок кода, а *затем* проверяет условие. Гарантирует как минимум одно выполнение.
* **Код:**
```c++
int i = 5;
do {
    std::cout << "Это сообщение выведется один раз" << std::endl;
    i++;
} while (i < 3);
```
* **Разбор кода:** Код внутри `do {}` выполняется один раз. Затем проверяется условие `i < 3` (5 < 3), которое ложно. Цикл завершается.

---

**`for`**
* **Пояснение:** Самый распространенный цикл. Состоит из трёх частей: инициализация счётчика, условие продолжения и изменение счётчика. Используется когда количество итераций известно заранее.
* **Код:**
```c++
for (int i = 0; i < 3; i++) {
    std::cout << i << std::endl;
}
```
* **Разбор кода:**
  1. **Инициализация:** `int i = 0` выполняется один раз
  2. **Условие:** `i < 3` проверяется перед каждой итерацией
  3. **Тело цикла:** выполняется если условие истинно
  4. **Инкремент:** `i++` выполняется после каждой итерации

---

**`for` на основе диапазона (Range-based for)**
* **Пояснение:** Упрощенная версия `for` для перебора всех элементов в контейнере. Используется для удобного и безопасного перебора коллекций.
* **Код:**
```c++
int numbers[] = {10, 20, 30};
for (int n : numbers) {
    std::cout << n << std::endl;
}
```
* **Разбор кода:** Цикл последовательно перебирает все элементы массива `numbers`. На каждой итерации переменная `n` принимает значение очередного элемента.

---

### Операторы перехода

**`break`**
* **Пояснение:** Немедленно завершает выполнение самого внутреннего цикла или оператора `switch`. Используется для досрочного выхода при выполнении условия.
* **Код:**
```c++
for (int i = 0; i < 10; i++) {
    if (i == 3) {
        break; // Выход из цикла, когда i равно 3
    }
    std::cout << i << std::endl;
}
```
* **Разбор кода:** Цикл выведет числа `0`, `1`, `2`. Когда `i` станет равно 3, `break` немедленно прекратит выполнение цикла.

---

**`continue`**
* **Пояснение:** Пропускает оставшуюся часть текущей итерации цикла и переходит к следующей. Используется чтобы пропустить обработку некоторых элементов.
* **Код:**
```c++
for (int i = 0; i < 5; i++) {
    if (i == 2) {
        continue; // Пропустить итерацию, когда i равно 2
    }
    std::cout << i << std::endl;
}
```
* **Разбор кода:** Программа выведет `0`, `1`, `3`, `4`. Когда `i` будет равно 2, `continue` пропустит команду вывода и перейдёт к следующей итерации.

---

**`goto`**
* **Пояснение:** Безусловно передаёт управление в точку программы, отмеченную меткой. Используется крайне редко, так как делает код запутанным.
* **Код:**
```c++
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            goto end_loops; // Прыжок к метке
        }
        std::cout << "i=" << i << ", j=" << j << std::endl;
    }
}
end_loops: // Метка
std::cout << "Циклы завершены" << std::endl;
```
* **Разбор кода:** Когда `i` и `j` станут равны 1, `goto` передаст управление к метке `end_loops:`, пропустив оставшиеся итерации.

---

**`return`**
* **Пояснение:** Завершает выполнение текущей функции и опционально возвращает значение в вызывающий код.
* **Код:**
```c++
int sum(int a, int b) {
    if (a < 0 || b < 0) {
        return 0; // Досрочный выход, если числа отрицательные
    }
    return a + b; // Возврат результата
}
```
* **Разбор кода:** `return` используется для возврата значения и может быть использован для немедленного прекращения работы функции.