# Встроенные типы


### Тип `void`

* **Пояснение:**
  `void` — это специальный тип, который буквально означает "отсутствие типа" или "пустота". Он используется в трёх основных случаях:
  1. Когда функция не возвращает никакого значения (процедура)
  2. Когда функция не принимает никаких аргументов
  3. Для объявления "универсального" указателя (`void*`), который может указывать на данные любого типа

* **Код:**
```c++
#include <iostream>

// 1. Функция не возвращает значение
void printMessage(const char* message) {
    std::cout << message << std::endl;
}

int main() {
    // 3. Универсальный указатель
    int number = 10;
    void* genericPointer = &number;

    // Нужно явно преобразовать тип, чтобы использовать данные
    int* intPointer = static_cast<int*>(genericPointer);
    std::cout << "Значение по указателю: " << *intPointer << std::endl;

    printMessage("Привет!");
    return 0;
}
```

* **Разбор кода:**
  Функция `printMessage` имеет тип возвращаемого значения `void`, поэтому она просто выполняет действие и не использует `return` со значением. В `main` создаем указатель `void*`, который хранит адрес целого числа. Чтобы получить доступ к числу, нужно преобразовать его в конкретный тип с помощью `static_cast`.

---

### Тип `bool`

* **Пояснение:**
  Логический или булев тип. Может хранить только два значения: `true` (истина) или `false` (ложь). Используется для хранения результатов логических операций, флагов состояния и в условных операторах.

* **Код:**
```c++
#include <iostream>

int main() {
    bool isUserLoggedIn = true;
    bool hasAdminRights = false;

    if (isUserLoggedIn) {
        std::cout << "Пользователь вошел." << std::endl;
    }

    if (!hasAdminRights) { // ! - оператор "НЕ"
        std::cout << "Админские права отсутствуют." << std::endl;
    }
}
```

* **Разбор кода:**
  Переменная `isUserLoggedIn` установлена в `true`, поэтому первое условие `if` выполняется. `hasAdminRights` установлена в `false`, поэтому условие с оператором отрицания `!` также выполняется.

---

### Символьные типы (`char`, `wchar_t`, `char8_t`, `char16_t`, `char32_t`)

* **Пояснение:**
  Типы для хранения символов:
  - `char`: Базовый символьный тип (1 байт, ASCII)
  - `wchar_t`: "Широкий" символ для расширенных наборов символов
  - `char8_t`, `char16_t`, `char32_t`: Типы для поддержки Unicode (UTF-8, UTF-16, UTF-32)

* **Код:**
```c++
#include <iostream>

int main() {
    // Обычный 1-байтовый символ (ASCII)
    char symbol = 'A';

    // Широкий символ (префикс L)
    wchar_t wideSymbol = L'Ω'; // Греческая Омега

    // Символ UTF-8 (C++20, префикс u8)
    char8_t utf8Symbol = u8'R';

    std::cout << "Обычный символ: " << symbol << std::endl;
    
    // Для вывода wchar_t нужен std::wcout
    std::wcout << L"Широкий символ: " << wideSymbol << std::endl;
}
```

* **Разбор кода:**
  Объявляем `char` для простого символа 'A'. Для `wchar_t` используем префикс `L` перед символом. Для вывода `wchar_t` используем `std::wcout` вместо `std::cout`.

---

### Целочисленные типы (`int`, `short`, `long`, `long long`)

* **Пояснение:**
  Типы для хранения целых чисел. Различаются размером и диапазоном значений:
  - `short`: Короткое целое (минимум 2 байта)
  - `int`: Стандартное целое (обычно 4 байта)
  - `long`: Длинное целое (минимум 4 байта)
  - `long long`: Очень длинное целое (минимум 8 байт)

  **Модификаторы:** `signed` (знаковые, по умолчанию) и `unsigned` (беззнаковые, только положительные числа)

* **Код:**
```c++
#include <iostream>

int main() {
    // Стандартное целое (обычно 4 байта)
    int score = 1500;

    // Короткое целое (обычно 2 байта)
    short temperature = -5;

    // Длинное целое для больших чисел
    long population = 140000000;

    // Беззнаковый int, не может быть отрицательным
    unsigned int itemCount = 100;

    std::cout << "Очки: " << score << std::endl;
    std::cout << "Население: " << population << std::endl;
    std::cout << "Кол-во: " << itemCount << std::endl;
}
```

* **Разбор кода:**
  Используем разные целочисленные типы для разных нужд: `int` для обычного счета, `long` для большого числа, `short` для маленького числа и `unsigned int` для количества, которое не может быть отрицательным.

---

### Типы с плавающей запятой (`float`, `double`, `long double`)

* **Пояснение:**
  Типы для хранения вещественных (дробных) чисел. Различаются точностью:
  - `float`: Число одинарной точности (обычно 4 байта)
  - `double`: Число двойной точности (обычно 8 байт, тип по умолчанию)
  - `long double`: Число повышенной точности (8 или 16 байт)

* **Код:**
```c++
#include <iostream>
#include <iomanip> // Для установки точности вывода

int main() {
    // Одинарная точность, нужен суффикс 'f'
    float pi_float = 3.14159265f;

    // Двойная точность (стандарт)
    double pi_double = 3.141592653589793;

    std::cout << std::setprecision(10); // Показать 10 знаков
    std::cout << "float: " << pi_float << std::endl;
    std::cout << "double: " << pi_double << std::endl;
}
```

* **Разбор кода:**
  Для `float` используем суффикс `f`, иначе число будет считаться типом `double`. При выводе с высокой точностью видно, что `float` теряет точность быстрее, чем `double`.

---

### Тип `std::nullptr_t` (и константа `nullptr`)

* **Пояснение:**
  `nullptr` — ключевое слово, представляющее "нулевой указатель". `std::nullptr_t` — тип этой константы. Использование `nullptr` вместо `0` или `NULL` безопаснее и яснее.

* **Код:**
```c++
#include <iostream>

void processPointer(int* ptr) {
    if (ptr != nullptr) {
        std::cout << "Указатель валидный, значение: " << *ptr << std::endl;
    } else {
        std::cout << "Получен нулевой указатель!" << std::endl;
    }
}

int main() {
    int number = 42;
    int* p1 = &number;
    int* p2 = nullptr; // Явно указываем, что p2 пустой

    processPointer(p1);
    processPointer(p2);
}
```

* **Разбор кода:**
  Функция `processPointer` проверяет, не является ли переданный указатель `nullptr`, прежде чем получить по нему значение. Это стандартная практика безопасности.