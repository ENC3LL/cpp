# Встроенные операторы C++, приоритет и ассоциативность

Язык C++ включает все операторы C и еще несколько новых операторов. Операторы определяют, какое вычисление следует выполнить с одним или несколькими операндами.

## Очередность и ассоциативность

Приоритет *оператора* определяет порядок операций в выражениях, содержащих несколько операторов. Ассоциативность *оператора* указывает, в выражении, которое содержит несколько операторов с одинаковым приоритетом, операнд сгруппирован с одним слева или одним справа.

## Альтернативные орфографии

C++ задает альтернативные орфографии для некоторых операторов. В C альтернативные орфографии предоставляются в виде макросов в заголовке <iso646.h> . В C++эти альтернативные варианты являются ключевыми словами, а использование <iso646.h> или эквивалентной <C++ ciso646> не рекомендуется. В Microsoft C++ `/permissive-`параметр или `/Za` компилятор требуется для включения альтернативных орфографических ошибок.

## Приоритет оператора C++ и таблица ассоциативности

В следующей таблице показан приоритет и ассоциативность операторов C++ (в порядке убывания приоритета). Операторы с тем же номером приоритета имеют равный приоритет, если другие связи не заданы явно с помощью круглых скобок.

![image](./.assets/image-1760634118603.png)
![image](./.assets/image-1760634136329.png)
![image](./.assets/image-1760634157575.png)
![image](./.assets/image-1760634177654.png)
![image](./.assets/image-1760634260770.png)

Конечно, вот исправленная версия в запрошенном формате:


### Операторы области

### `::` (Разрешение области)
* **Пояснение:** Используется для доступа к членам пространства имен (например, `std::cout`), статическим членам класса (`MyClass::static_var`) или для явного указания глобальной области (`::global_var`).
* **Код:**
```c++
#include <iostream>
int count = 100; // Глобальная переменная

namespace MySpace {
    int count = 10;
}

int main() {
    int count = 1; // Локальная переменная
    std::cout << count << std::endl;       // 1
    std::cout << MySpace::count << std::endl; // 10
    std::cout << ::count << std::endl;     // 100
}
```
* **Разбор кода:** `std::cout` обращается к `cout` в `std`. `MySpace::count` берет переменную из `MySpace`. `::count` берет глобальную переменную, игнорируя локальную.

---

### Постфиксные операторы (выполняются слева направо)

### `()` (Вызов функции и создание)
* **Пояснение:** Оператор `()` используется для вызова функции или метода (с передачей аргументов в скобках). Также используется для создания временных объектов или инициализации.
* **Код:**
```c++
int add(int a, int b) {
    return a + b;
}
int x = add(5, 3); // x = 8
int y = int(10); // y = 10 (функциональное приведение типа)
```
* **Разбор кода:** `add(5, 3)` вызывает функцию `add`. `int(10)` создает `int` со значением 10.

### `[]` (Индекс массива)
* **Пояснение:** Получает доступ к элементу массива или контейнера (например, `std::vector`) по его индексу (номеру).
* **Код:**
```c++
int arr[3] = {10, 20, 30};
int second = arr[1]; // second = 20
```
* **Разбор кода:** `arr[1]` обращается ко *второму* элементу массива, так как индексация в C++ начинается с 0.

### `.` (Доступ к члену) и `->` (Доступ к члену через указатель)
* **Пояснение:** `.` используется для доступа к полям или методам *объекта*. `->` используется для доступа к полям или методам *указателя* на объект.
* **Код:**
```c++
#include <string>
struct Person { std::string name; };

Person p1;
p1.name = "Ivan"; // Используем . для объекта

Person* p2 = new Person();
p2->name = "Anna"; // Используем -> для указателя
delete p2;
```
* **Разбор кода:** `p1` — это сам объект, поэтому используем точку. `p2` — это указатель на объект, поэтому используем стрелку (что эквивалентно `(*p2).name`).

### `++` (Постфиксный инкремент) и `--` (Постфиксный декремент)
* **Пояснение:** Увеличивает (`++`) или уменьшает (`--`) значение переменной *после* того, как ее текущее значение было использовано в выражении.
* **Код:**
```c++
int x = 5;
int y = x++; // y = 5, x становится 6
int z = x--; // z = 6, x становится 5
```
* **Разбор кода:** `y` получает значение `x` (5), и *только потом* `x` увеличивается. `z` получает текущее значение `x` (6), и *потом* `x` уменьшается.

### `typeid`, `const_cast`, `dynamic_cast`, `reinterpret_cast`, `static_cast`
* **Пояснение:** Это операторы приведения типов и RTTI.
    * `typeid`: Возвращает информацию о типе во время выполнения.
    * `const_cast`: Снимает `const` или `volatile` квалификаторы.
    * `dynamic_cast`: Безопасно приводит типы указателей/ссылок в иерархии классов (проверяется во время выполнения).
    * `static_cast`: Выполняет "безопасные" приведения типов во время компиляции (например, `int` в `double`).
    * `reinterpret_cast`: "Опасное" приведение, просто интерпретирует биты одного типа как другой (например, `int*` в `char*`).
* **Код:**
```c++
double d = 10.5;
int i = static_cast<int>(d); // i = 10

const int c = 5;
int* p = const_cast<int*>(&c); // p теперь указывает на c как на не-константу

int x = 100;
char* char_ptr = reinterpret_cast<char*>(&x);
```
* **Разбор кода:** `static_cast` — самый частый способ приведения простых типов. `const_cast` используется для изменения константности (редко). `reinterpret_cast` — низкоуровневая операция.

---

### Унарные операторы (выполняются справа налево)

### `sizeof` (Размер)
* **Пояснение:** Возвращает размер типа или переменной в байтах. Вычисляется во время компиляции.
* **Код:**
```c++
#include <cstddef> // для size_t
size_t intSize = sizeof(int); // Обычно 4 или 8
int arr[10];
size_t arrSize = sizeof(arr); // 4 * 10 = 40 (если int 4 байта)
```
* **Разбор кода:** `sizeof(int)` сообщает, сколько байт занимает один `int`. `sizeof(arr)` сообщает общий размер всего массива.

### `++` (Префиксный инкремент) и `--` (Префиксный декремент)
* **Пояснение:** Увеличивает (`++`) или уменьшает (`--`) значение переменной *до* того, как ее новое значение будет использовано в выражении.
* **Код:**
```c++
int x = 5;
int y = ++x; // x становится 6, y = 6
int z = --x; // x становится 5, z = 5
```
* **Разбор кода:** `x` *сначала* увеличивается до 6, и *затем* `y` получает это новое значение.

### `~` (Побитовое НЕ / Дополнение)
* **Пояснение:** Инвертирует *каждый* бит в байте числа (0 становится 1, 1 становится 0).
* **Код:**
```c++
// 5 = 0b00000101
// ~5 = 0b11111010 (это -6 в доп. коде)
int x = 5;
int y = ~x;
```
* **Разбор кода:** Оператор `~` перевернул все нули на единицы и единицы на нули.

### `!` (Логическое НЕ)
* **Пояснение:** Инвертирует булево значение. `true` становится `false`, а `false` (или 0) становится `true`.
* **Код:**
```c++
bool isReady = false;
if (!isReady) { // "если НЕ готово"
    // ... выполнится
}
```
* **Разбор кода:** `!isReady` вычисляется как `true`, потому что `isReady` — `false`.

### `-` (Унарный минус) и `+` (Унарный плюс)
* **Пояснение:** `-` меняет знак числа (положительное на отрицательное и наоборот). `+` в основном ничего не делает, существует для симметрии.
* **Код:**
```c++
int x = 10;
int y = -x; // y = -10
int z = -y; // z = 10
```
* **Разбор кода:** `-x` возвращает арифметическое отрицание `x`.

### `&` (Взятие адреса) и `*` (Разыменование)
* **Пояснение:** `&` (адрес) возвращает адрес переменной в памяти (создает указатель). `*` (разыменование) получает значение, которое хранится по адресу, на который указывает указатель.
* **Код:**
```c++
int a = 10;
int* p = &a; // p теперь хранит адрес 'a'
*p = 20;      // 'a' теперь равно 20
int b = *p;   // b = 20
```
* **Разбор кода:** `&a` получает адрес `a`. `*p` "идет" по адресу, хранящемуся в `p`, и получает или изменяет значение, которое там лежит (т.е. `a`).

### `new` и `delete` (Выделение и освобождение памяти)
* **Пояснение:** `new` выделяет память в "куче" (heap) для объекта и возвращает указатель. `delete` освобождает эту память. `delete[]` нужен для массивов, выделенных через `new[]`.
* **Код:**
```c++
int* num = new int(50); // Выделили память для int
*num = 55;
delete num; // Освободили память

int* arr = new int[10]; // Выделили память для массива
delete[] arr; // Освободили массив
```
* **Разбор кода:** `new` запрашивает память у системы. `delete` возвращает ее, чтобы избежать утечек памяти.

### `()` (Приведение типов)
* **Пояснение:** Используется для явного преобразования одного типа в другой (в стиле C). В C++ предпочитают `static_cast` и другие.
* **Код:**
```c++
double d = 10.8;
int i = (int)d; // i = 10
```
* **Разбор кода:** `(int)d` отбрасывает дробную часть `d` и преобразует значение в `int`.

---

### Операторы указателя на член

### `.*` и `->*`
* **Пояснение:** Редкие операторы. Используются для доступа к члену класса через *указатель на член*. `.*` для объектов, `->*` для указателей на объекты.
* **Код:**
```c++
struct MyClass { int value; };
int MyClass::*ptr_to_member = &MyClass::value; // Указатель на член 'value'

MyClass obj;
obj.*ptr_to_member = 10; // obj.value = 10

MyClass* obj_ptr = &obj;
obj_ptr->*ptr_to_member = 20; // obj.value = 20
```
* **Разбор кода:** `ptr_to_member` — это не обычный указатель, а "смещение" или "рецепт" того, как найти `value` внутри `MyClass`. Операторы `.*` и `->*` применяют этот "рецепт" к реальному объекту.

---

### Мультипликативные операторы (слева направо)

### `*` (Умножение), `/` (Деление), `%` (Остаток от деления)
* **Пояснение:** Стандартные арифметические операции. `%` (модуль) возвращает остаток от целочисленного деления.
* **Код:**
```c++
int product = 5 * 4; // 20
int quotient = 20 / 3; // 6 (целочисленное деление, остаток отброшен)
int remainder = 20 % 3; // 2 (так как 20 = 6*3 + 2)
```
* **Разбор кода:** `20 / 3` дает 6, потому что оба операнда целые. `20 % 3` дает остаток 2.

---

### Аддитивные операторы (слева направо)

### `+` (Сложение) и `-` (Вычитание)
* **Пояснение:** Стандартные бинарные (между двумя числами) арифметические операции.
* **Код:**
```c++
int sum = 10 + 5; // 15
int diff = 10 - 15; // -5
```
* **Разбор кода:** Выполняют сложение и вычитание.

---

### Операторы побитового сдвига (слева направо)

### `<<` (Сдвиг влево) и `>>` (Сдвиг вправо)
* **Пояснение:** Сдвигают биты числа влево или вправо на указанное количество позиций. `<< n` эквивалентно умножению на 2^n. `>> n` — делению на 2^n.
* **Код:**
```c++
#include <iostream>
// 5 = 0b00000101
int x = 5 << 1; // 0b00001010 = 10
int y = 5 >> 1; // 0b00000010 = 2

// Также перегружен для вывода в потоки
std::cout << "Hello";
```
* **Разбор кода:** `5 << 1` сдвинуло все биты на 1 влево (получилось 10). `5 >> 1` сдвинуло на 1 вправо (получилось 2).

---

### Операторы сравнения (слева направо)

### `<`, `>`, `<=`, `>=`
* **Пояснение:** Сравнивают два значения (меньше, больше, меньше или равно, больше или равно). Возвращают `true` или `false`.
* **Код:**
```c++
bool b1 = (10 > 5); // true
bool b2 = (5 < 5);  // false
bool b3 = (5 <= 5); // true
```
* **Разбор кода:** Выполняют математическое сравнение.

---

### Операторы равенства (слева направо)

### `==` (Равно) и `!=` (Не равно)
* **Пояснение:** Проверяют, равны ли два значения (`==`) или не равны (`!=`).
* **Код:**
```c++
bool b1 = (5 == 5); // true
bool b2 = (5 != 10); // true
bool b3 = ('a' == 'A'); // false
```
* **Разбор кода:** Важно не путать `==` (сравнение) с `=` (присваивание).

---

### Побитовые операторы (слева направо)

### `&` (Побитовое И)
* **Пояснение:** Выполняет операцию "И" над каждой парой битов двух чисел. Бит результата 1, только если *оба* бита операндов 1.
* **Код:**
```c++
// 5 = 0b0101
// 3 = 0b0011
int result = 5 & 3; // 0b0001 = 1
```
* **Разбор кода:** Только первый бит (справа) был 1 в *обоих* числах, поэтому в результате 1.

### `^` (Побитовое Исключающее ИЛИ / XOR)
* **Пояснение:** Бит результата 1, только если биты операндов *разные* (один 1, другой 0).
* **Код:**
```c++
// 5 = 0b0101
// 3 = 0b0011
int result = 5 ^ 3; // 0b0110 = 6
```
* **Разбор кода:** Биты 1 и 2 (считая справа) были разными (0/1 и 1/0), поэтому в результате они стали 1.

### `|` (Побитовое ИЛИ)
* **Пояснение:** Бит результата 1, если *хотя бы один* из битов операндов 1.
* **Код:**
```c++
// 5 = 0b0101
// 3 = 0b0011
int result = 5 | 3; // 0b0111 = 7
```
* **Разбор кода:** Биты 0, 1 и 2 (справа) имели хотя бы одну единицу, поэтому в результате они стали 1.

---

### Логические операторы (слева направо)

### `&&` (Логическое И)
* **Пояснение:** Возвращает `true`, только если *оба* операнда `true`. Использует "короткую схему": если левый операнд `false`, правый даже не вычисляется.
* **Код:**
```c++
int age = 20;
bool hasLicense = true;
if (age > 18 && hasLicense) {
    // ... выполнится
}
```
* **Разбор кода:** Так как `age > 18` (true) И `hasLicense` (true), общее условие истинно.

### `||` (Логическое ИЛИ)
* **Пояснение:** Возвращает `true`, если *хотя бы один* операнд `true`. Использует "короткую схему": если левый операнд `true`, правый не вычисляется.
* **Код:**
```c++
bool isAdmin = false;
bool isOwner = true;
if (isAdmin || isOwner) {
    // ... выполнится
}
```
* **Разбор кода:** `isAdmin` (false), но `isOwner` (true), поэтому общее условие истинно.

---

### Условный оператор (Тернарный) (справа налево)

### `?:`
* **Пояснение:** Короткая запись `if-else`. Формат: `(условие) ? (значение_если_true) : (значение_если_false)`.
* **Код:**
```c++
int x = 10;
int y = (x > 5) ? 100 : 200; // y = 100
```
* **Разбор кода:** Условие `x > 5` истинно, поэтому `y` получает значение *до* двоеточия (100).

---

### Операторы присваивания (справа налево)

### `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=`, `&=`, `^=`, `|=`
* **Пояснение:** `=` просто присваивает значение. Составные операторы (например, `+=`) выполняют операцию и присваивают результат. `x += 5` — это то же самое, что `x = x + 5`.
* **Код:**
```c++
int x = 10; // Присваивание
x += 5;     // x = 15 (x = x + 5)
x *= 2;     // x = 30 (x = x * 2)
x %= 4;     // x = 2  (x = x % 4)
x |= 1;     // x = 3  (x = 0b0010 | 0b0001)
```
* **Разбор кода:** Это удобный и более короткий способ изменить значение переменной на основе ее текущего значения.

---

### Оператор `throw` (Выброс исключения)

### `throw`
* **Пояснение:** Генерирует (выбрасывает) исключение. Используется для сигнализации об ошибке, которая должна быть обработана где-то выше по стеку вызовов (в блоке `try...catch`).
* **Код:**
```c++
#include <stdexcept> // для runtime_error

int divide(int a, int b) {
    if (b == 0) {
        throw std::runtime_error("Division by zero!");
    }
    return a / b;
}
```
* **Разбор кода:** Если `b` равно 0, функция прерывает свою работу и "выбрасывает" ошибку, которую можно поймать в блоке `catch`.

---

### Оператор `,` (Запятая) (слева направо)

### `,`
* **Пояснение:** Выполняет несколько выражений (слева направо) и возвращает результат *последнего* выражения. Используется редко, в основном в циклах `for`.
* **Код:**
```c++
int a, b;
int k = (a = 5, b = 10, a + b); // k = 15

// Используется в цикле for
for (int i = 0, j = 10; i < j; ++i, --j) {
    // ...
}
```
* **Разбор кода:** В `k` сначала выполнилось `a = 5`, потом `b = 10`, и `k` получило результат последнего выражения `a + b` (15). В `for` запятая позволяет инициализировать и изменять две переменные одновременно.