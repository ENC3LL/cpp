# Решение задания 41

Shopping.py

```python
import csv
import sys

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier

TEST_SIZE = 0.4


def main():

    # Check command-line arguments
    if len(sys.argv) != 2:
        sys.exit("Usage: python shopping.py data")

    # Load data from spreadsheet and split into train and test sets
    evidence, labels = load_data(sys.argv[1])
    X_train, X_test, y_train, y_test = train_test_split(
        evidence, labels, test_size=TEST_SIZE
    )

    # Train model and make predictions
    model = train_model(X_train, y_train)
    predictions = model.predict(X_test)
    sensitivity, specificity = evaluate(y_test, predictions)

    # Print results
    print(f"Correct: {(y_test == predictions).sum()}")
    print(f"Incorrect: {(y_test != predictions).sum()}")
    print(f"True Positive Rate: {100 * sensitivity:.2f}%")
    print(f"True Negative Rate: {100 * specificity:.2f}%")


def load_data(filename):
    """
    Load shopping data from a CSV file `filename` and convert into a list of
    evidence lists and a list of labels. Return a tuple (evidence, labels).

    evidence should be a list of lists, where each list contains the
    following values, in order:
        - Administrative, an integer
        - Administrative_Duration, a floating point number
        - Informational, an integer
        - Informational_Duration, a floating point number
        - ProductRelated, an integer
        - ProductRelated_Duration, a floating point number
        - BounceRates, a floating point number
        - ExitRates, a floating point number
        - PageValues, a floating point number
        - SpecialDay, a floating point number
        - Month, an index from 0 (January) to 11 (December)
        - OperatingSystems, an integer
        - Browser, an integer
        - Region, an integer
        - TrafficType, an integer
        - VisitorType, an integer 0 (not returning) or 1 (returning)
        - Weekend, an integer 0 (if false) or 1 (if true)

    labels should be the corresponding list of labels, where each label
    is 1 if Revenue is true, and 0 otherwise.
    """
    evidence = []
    labels = []

    # Словарь для преобразования месяцев в целые числа
    month_mapping = {
        "Jan": 0, "Feb": 1, "Mar": 2, "Apr": 3, "May": 4, "June": 5,
        "Jul": 6, "Aug": 7, "Sep": 8, "Oct": 9, "Nov": 10, "Dec": 11
    }

    with open(filename) as f:
        reader = csv.reader(f)
        next(reader)  # Пропустить строку заголовка

        for row in reader:
            evidence_row = []
            # Преобразование данных в соответствии со спецификацией
            evidence_row.append(int(row[0]))  # Administrative
            evidence_row.append(float(row[1]))  # Administrative_Duration
            evidence_row.append(int(row[2]))  # Informational
            evidence_row.append(float(row[3]))  # Informational_Duration
            evidence_row.append(int(row[4]))  # ProductRelated
            evidence_row.append(float(row[5]))  # ProductRelated_Duration
            evidence_row.append(float(row[6]))  # BounceRates
            evidence_row.append(float(row[7]))  # ExitRates
            evidence_row.append(float(row[8]))  # PageValues
            evidence_row.append(float(row[9]))  # SpecialDay
            evidence_row.append(month_mapping[row[10]])  # Month
            evidence_row.append(int(row[11]))  # OperatingSystems
            evidence_row.append(int(row[12]))  # Browser
            evidence_row.append(int(row[13]))  # Region
            evidence_row.append(int(row[14]))  # TrafficType
            # VisitorType: 1 для returning, 0 для остальных
            evidence_row.append(1 if row[15] == "Returning_Visitor" else 0)
            # Weekend: 1 для TRUE, 0 для FALSE
            evidence_row.append(1 if row[16] == "TRUE" else 0)
            
            evidence.append(evidence_row)
            
            # Labels: 1 для TRUE (покупка), 0 для FALSE
            labels.append(1 if row[17] == "TRUE" else 0)

    return (evidence, labels)


def train_model(evidence, labels):
    """
    Given a list of evidence lists and a list of labels, return a
    fitted k-nearest neighbor model (k=1) trained on the data.
    """
    # Создаем классификатор k-ближайших соседей, где k=1
    model = KNeighborsClassifier(n_neighbors=1)
    
    # Обучаем модель на данных
    model.fit(evidence, labels)
    return model


def evaluate(labels, predictions):
    """
    Given a list of actual labels and a list of predicted labels,
    return a tuple (sensitivity, specificity).

    Assume each label is either a 1 (positive) or 0 (negative).

    `sensitivity` should be a floating-point value from 0 to 1
    representing the "true positive rate": the proportion of
    actual positive labels that were accurately identified.

    `specificity` should be a floating-point value from 0 to 1
    representing the "true negative rate": the proportion of
    actual negative labels that were accurately identified.
    """
    total_positives = 0
    true_positives = 0
    total_negatives = 0
    true_negatives = 0

    # Итерация по фактическим и предсказанным меткам
    for actual, predicted in zip(labels, predictions):
        if actual == 1:  # Фактически положительный
            total_positives += 1
            if predicted == 1:
                true_positives += 1
        elif actual == 0:  # Фактически отрицательный
            total_negatives += 1
            if predicted == 0:
                true_negatives += 1

    # Расчет чувствительности (True Positive Rate)
    sensitivity = true_positives / total_positives
    
    # Расчет специфичности (True Negative Rate)
    specificity = true_negatives / total_negatives

    return (sensitivity, specificity)


if __name__ == "__main__":
    main()
```




## Фон
Когда пользователи совершают покупки в Интернете, не все в конечном итоге что-то покупают. Большинство посетителей веб-сайта онлайн-покупок, скорее всего, в конечном итоге не совершают покупку во время сеанса просмотра веб-страниц. Тем не менее, для торгового сайта может быть полезно иметь возможность предсказывать, намерен ли пользователь совершить покупку или нет: возможно, отображать пользователю другой контент, например, показывать пользователю предложение скидки, если веб-сайт считает, что пользователь не планирует совершать покупку. Как сайт может определить покупательское намерение пользователя? Вот тут-то и придет на помощь машинное обучение.

Ваша задача в этой задаче состоит в том, чтобы построить классификатор ближайшего соседа для решения этой задачи. Получив информацию о пользователе — сколько страниц он посетил, совершает ли он покупки в выходные, какой веб-браузер он использует и т. д. — ваш классификатор предскажет, совершит ли пользователь покупку. Ваш классификатор не будет идеально точным — идеальное моделирование человеческого поведения — это задача, выходящая далеко за рамки этого класса, — но он должен быть лучше, чем угадывание случайным образом. Чтобы обучить ваш классификатор, мы предоставим вам некоторые данные с веб-сайта магазина из примерно 12 000 сеансов пользователей.

Как мы измеряем точность такой системы? Если у нас есть тестовый набор данных, мы можем запустить наш классификатор на данных и вычислить, в какой части времени мы правильно классифицируем намерения пользователя. Это дало бы нам единый процент точности. Но эта цифра может немного ввести в заблуждение. Представьте, например, что около 15% всех пользователей в конечном итоге совершают покупку. Классификатор, который всегда предсказывал, что пользователь не совершит покупку, мы бы измерили как 85% точный: единственные пользователи, которых он классифицирует неправильно, — это 15% пользователей, которые совершают покупку. И хотя точность 85% звучит довольно неплохо, это не кажется очень полезным классификатором.

Вместо этого мы будем измерять два значения: чувствительность (также известную как «истинно положительный процент») и специфичность (также известную как «истинно отрицательный процент»). Чувствительность относится к доле положительных примеров, которые были правильно идентифицированы: другими словами, доля пользователей, которые совершили покупку, но были правильно идентифицированы. Специфичность относится к доле негативных примеров, которые были правильно идентифицированы: в данном случае это доля пользователей, которые не совершили покупку, но были правильно идентифицированы. Таким образом, наш предыдущий классификатор «всегда угадывай нет» будет иметь идеальную специфичность (1,0), но не будет чувствительности (0,0). Наша цель — создать классификатор, который будет работать разумно по обеим метрикам.

[](#)## [Начало работы](https://cs50.harvard.edu/ai/projects/4/shopping/#getting-started)* **Скачайте код дистрибутива из [https://cdn.cs50.net/ai/2023/x/projects/4/shopping.zip](https://cdn.cs50.net/ai/2023/x/projects/4/shopping.zip) и распакуйте его.
* **Запустите для установки пакета, если он еще не установлен, что вам понадобится для этого проекта.`pip3 install scikit-learn``scikit-learn`

[](#)## [Понимание](https://cs50.harvard.edu/ai/projects/4/shopping/#understanding)Во-первых, откройте набор данных, предоставленный вам для этого проекта. Вы можете открыть его в текстовом редакторе, но вам может быть легче понять его визуально в приложении для работы с электронными таблицами, таком как Microsoft Excel, Apple Numbers или Google Sheets.`shopping.csv`

В этой таблице представлено около 12 000 пользовательских сеансов: они представлены в виде одной строки для каждого пользовательского сеанса. Первые шесть столбцов измеряют различные типы страниц, которые пользователи посетили в сеансе: столбцы , и столбцы измеряют, сколько страниц этих типов посетил пользователь, а соответствующие столбцы измеряют, сколько времени пользователь провел на любой из этих страниц. Столбцы , и измеряют информацию из Google Analytics о странице, которую посетил пользователь. — это значение, которое измеряет, насколько близка дата сеанса пользователя к определенному дню (например, Дню святого Валентина или Дню матери). — это аббревиатура месяца, в котором пользователь посетил. , , , и — все это целые числа, описывающие информацию о самом пользователе. примет значение для возвращающихся посетителей и какое-либо другое строковое значение для невернувшихся посетителей. или в зависимости от того, посещает ли пользователь в выходные дни.`Administrative``Informational``ProductRelated``_Duration``BounceRates``ExitRates``PageValues``SpecialDay``Month``OperatingSystems``Browser``Region``TrafficType``VisitorType``Returning_Visitor``Weekend``TRUE``FALSE`

Однако, пожалуй, самая важная колонка — последняя: колонка. Это столбец, который указывает, совершил ли пользователь в итоге покупку или нет: если совершил, то нет. Это столбец, который мы хотели бы научиться прогнозировать («метка») на основе значений для всех остальных столбцов («доказательство»).`Revenue``TRUE``FALSE`

Далее взгляните на домен . Функция загружает данные из таблицы CSV путем вызова функции и разделяет данные на обучающий и тестовый наборы. Затем вызывается функция для обучения модели машинного обучения на обучающих данных. Затем модель используется для прогнозирования на основе тестового набора данных. Наконец, функция определяет чувствительность и специфичность модели, прежде чем результаты в конечном итоге будут выведены на терминал.`shopping.py``main``load_data``train_model``evaluate`

Функции , , и оставлены пустыми. Вот тут-то и вступаете в игру!`load_data``train_model``evaluate`

Функция должна принять имя файла CSV в качестве аргумента, открыть этот файл и вернуть кортеж . должен быть списком всех свидетельств для каждой из точек данных, а также должен быть списком всех меток для каждой точки данных.`load_data``(evidence, labels)``evidence``labels`

* **Поскольку у вас будет одно доказательство и одна метка для каждой строки таблицы, длина списка и длина списка в конечном итоге должны быть равны количеству строк в таблице CSV (за исключением строки заголовка). Списки должны быть упорядочены в соответствии с порядком, в котором пользователи отображаются в таблице. То есть, он должен быть свидетельством для первого пользователя, и должен быть ярлыком для первого пользователя.`evidence``labels``evidence[0]``labels[0]`
* **Каждый элемент в списке сам по себе должен быть списком. Длина списка должна быть 17: количество столбцов в таблице без учета последнего столбца (столбца с меткой).`evidence`
* **Значения в каждом списке должны располагаться в том же порядке, что и столбцы, отображаемые в таблице доказательств. Можно предположить, что порядок столбцов в нем всегда будет представлен в этом порядке.`evidence``shopping.csv`
* **Обратите внимание, что для построения классификатора по принципу ближайшего соседа все наши данные должны быть числовыми. Убедитесь, что ваши значения имеют следующие типы:* **`Administrative`, , , и все должны иметь тип `Informational``ProductRelated``Month``OperatingSystems``Browser``Region``TrafficType``VisitorType``Weekend``int`
* **`Administrative_Duration`, , , , , , и все они должны иметь тип .`Informational_Duration``ProductRelated_Duration``BounceRates``ExitRates``PageValues``SpecialDay``float`
* **`Month` должен быть за январь, за февраль, за март и т.д. вплоть до декабря.`0``1``2``11`
* **`VisitorType` должен быть для возвращающихся посетителей и для невернувшихся.`1``0`
* **`Weekend` Должно быть, если пользователь зашел в выходной день и в противном случае.`1``0`
* **`Administrative`, , , и все должны иметь тип `Informational``ProductRelated``Month``OperatingSystems``Browser``Region``TrafficType``VisitorType``Weekend``int`
* **`Administrative_Duration`, , , , , , и все они должны иметь тип .`Informational_Duration``ProductRelated_Duration``BounceRates``ExitRates``PageValues``SpecialDay``float`
* **`Month` должен быть за январь, за февраль, за март и т.д. вплоть до декабря.`0``1``2``11`
* **`VisitorType` должен быть для возвращающихся посетителей и для невернувшихся.`1``0`
* **`Weekend` Должно быть, если пользователь зашел в выходной день и в противном случае.`1``0`
* **Каждое значение должно быть либо целым числом , если пользователь совершил покупку, либо иначе.`labels``1``0`
* **Например, значение первого списка доказательств должно быть равным, а значение первой метки должно быть .`[0, 0.0, 0, 0.0, 1, 0.0, 0.2, 0.2, 0.0, 0.0, 1, 1, 1, 1, 1, 1, 0]``0`

Функция должна принимать список свидетельств и список меток и возвращать классификатор ближайшего соседа (классификатор k-ближайшего соседа, где ), подходящий для этих обучающих данных.`train_model``scikit-learn``k = 1`

* **Обратите внимание, что мы уже импортировали файлы . Вы захотите использовать a в этой функции.`from sklearn.neighbors import KNeighborsClassifier``KNeighborsClassifier`

Функция должна принимать список (истинные метки для пользователей в тестовом наборе) и список (метки, предсказанные вашим классификатором) и возвращать два значения с плавающей запятой.`evaluate``labels``predictions``(sensitivity, specificity)`

* **`sensitivity` должно быть значением с плавающей запятой от 0 до 1, представляющим «истинно положительный коэффициент»: долю фактически положительных меток, которые были точно идентифицированы.
* **`specificity` должно быть значением с плавающей запятой от 0 до 1, представляющим «истинно отрицательный коэффициент»: долю фактических отрицательных меток, которые были точно идентифицированы.
* **Вы можете предположить, что каждая метка будет означать положительные результаты (пользователи, которые совершили покупку) или отрицательные результаты (пользователи, которые не совершили покупку).`1``0`
* **Можно предположить, что список истинных меток будет содержать по крайней мере одну положительную метку и по крайней мере одну отрицательную метку.

Вы не должны изменять что-либо еще, кроме функций, которые спецификация призывает вас реализовать, хотя вы можете написать дополнительные функции и/или импортировать другие модули стандартной библиотеки Python. Вы также можете импортировать что-либо из , если вы знакомы с ними, но вы не должны использовать какие-либо другие сторонние модули Python. Не следует изменять домен .`shopping.py``numpy``pandas``scikit-learn``shopping.csv`



