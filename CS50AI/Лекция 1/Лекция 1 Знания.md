# Лекция 1 Знания

**Знание**

Люди рассуждают на основе существующих знаний и делают выводы. Концепция представления знаний и извлечения из них выводов также используется в ИИ, и на этой лекции мы исследуем, как можно достичь такого поведения.

**Основанные на знаниях агенты (Knowledge-Based Agents)**

Это агенты, которые рассуждают, оперируя внутренними представлениями знаний.

Что означает «рассуждение на основе знаний для получения вывода»?

Давайте начнем ответ с примера о Гарри Поттере. Рассмотрим следующие высказывания:

1.  Если дождя не было, Гарри навестил Хагрида сегодня.
2.  Гарри навестил Хагрида или Дамблдора сегодня, но не обоих.
3.  Гарри навестил Дамблдора сегодня.

Основываясь на этих трех высказываниях, мы можем ответить на вопрос «был ли сегодня дождь?», даже though ни одно из отдельных высказываний не говорит нам о том, был ли дождь. Вот как мы можем это сделать: посмотрев на высказывание 3, мы знаем, что Гарри навестил Дамблдора. Глядя на высказывание 2, мы знаем, что Гарри навестил либо Дамблдора, либо Хагрида, и, таким образом, можем заключить:

4.  Гарри не навещал Хагрида.

Теперь, глядя на высказывание 1, мы понимаем, что если дождя не было, Гарри навестил бы Хагрида. Однако, зная высказывание 4, мы знаем, что это не так. Следовательно, мы можем заключить:

5.  Сегодня шёл дождь.

Чтобы прийти к этому выводу, мы использовали логику, и сегодняшняя лекция исследует, как ИИ может использовать логику для получения новых выводов на основе существующей информации.

**Высказывание (Sentence)**

Высказывание — это утверждение о мире на языке представления знаний. Высказывание — это то, как ИИ хранит знания и использует их для вывода новой информации.

**Логика высказываний (Propositional Logic)**
Логика высказываний основана на пропозициях (высказываниях) — утверждениях о мире, которые могут быть либо истинными, либо ложными, как в высказываниях 1-5 выше.

**Пропозициональные символы (Propositional Symbols)**

Пропозициональные символы — чаще всего буквы (P, Q, R), которые используются для представления пропозиции.

**Логические связки (Logical Connectives)**

Логические связки — это логические символы, которые соединяют пропозициональные символы для более сложных рассуждений о мире.

*   **Не (¬)** инвертирует значение истинности пропозиции. Так, например, если P: «Идёт дождь», то ¬P: «Дождь не идёт».
*   **Таблицы истинности (Truth tables)** используются для сравнения всех возможных наборов значений истинности пропозиций. Этот инструмент поможет нам лучше понять значения истинности пропозиций, соединенных разными логическими связками. Например, вот наша первая таблица истинности:

| P     | ¬P     |
| :---- | :----- |
| ложь  | истина |
| истина | ложь   |

*   **И (∧)** соединяет две различные пропозиции. Когда эти две пропозиции, P и Q, соединены с помощью ∧, результирующая пропозиция P ∧ Q истинна только в том случае, если и P, и Q истинны.

| P     | Q     | P ∧ Q |
| :---- | :---- | :---- |
| ложь  | ложь  | ложь  |
| ложь  | истина | ложь  |
| истина | ложь  | ложь  |
| истина | истина | истина |

*   **Или (∨)** истинна, пока хотя бы один из ее аргументов истинен. Это означает, что для того, чтобы P ∨ Q была истинной, по крайней мере одна из P или Q должна быть истинной.

| P     | Q     | P ∨ Q |
| :---- | :---- | :---- |
| ложь  | ложь  | ложь  |
| ложь  | истина | истина |
| истина | ложь  | истина |
| истина | истина | истина |

Стоит упомянуть, что существует два типа «Или»: включающее (inclusive) и исключающее (exclusive). В исключающем «Или» P ∨ Q ложно, если P ∧ Q истинно. То есть исключающее «Или» требует, чтобы был истинен только один из аргументов, а не оба. Включающее «Или» истинно, если истинна любая из P, Q или P ∧ Q. В случае «Или» (∨) подразумевается включающее «Или».

Пару примечаний, не упомянутых в лекции:
*   Иногда пример помогает понять разницу. Включающее «Или»: «чтобы получить десерт, ты должен убраться в комнате или подстричь газон». В этом случае, если вы сделаете и то, и другое, вы все равно получите печенье. Исключающее «Или»: «На десерт ты можешь взять либо печенье, либо мороженое». В этом случае нельзя взять и то, и другое.
*   Если вам интересно, исключающее «Или» часто сокращается до XOR, и его common символ — ⊕.

*   **Импликация (→)** представляет структуру «если P, то Q». Например, если P: «Идёт дождь», а Q: «Я в помещении», то P → Q означает «Если идёт дождь, то я в помещении». В случае «P влечёт Q» (P → Q), P называется антецедентом (предпосылкой), а Q — консеквентом (следствием).

Когда антецедент истинен, вся импликация истинна в случае, если консеквент истинен (это имеет смысл: если идет дождь и я в помещении, то высказывание «если идет дождь, то я в помещении» истинно). Когда антецедент истинен, импликация ложна, если консеквент ложен (если я на улице во время дождя, то высказывание «Если идет дождь, то я в помещении» ложно). Однако, когда антецедент ложен, импликация всегда истинна, независимо от консеквента. Это иногда может быть confusing понятием. Логически мы не можем ничего узнать из импликации (P → Q), если антецедент (P) ложен. Смотря на наш пример, если дождя нет, импликация ничего не говорит о том, нахожусь ли я в помещении или нет. Я могу быть «домашним» типом и никогда не выходить на улицу, даже когда нет дождя, или я могу быть «уличным» типом и всегда быть на улице, когда нет дождя. Когда антецедент ложен, мы говорим, что импликация тривиально истинна (trivially true).

| P     | Q     | P → Q |
| :---- | :---- | :---- |
| ложь  | ложь  | истина |
| ложь  | истина | истина |
| истина | ложь  | ложь  |
| истина | истина | истина |

*   **Бикондиционал, Эквивалентность (↔)** — это импликация, которая работает в обе стороны. Можно прочитать это как «тогда и только тогда». P ↔ Q эквивалентно совмещённым P → Q и Q → P. Например, если P: «Идёт дождь», а Q: «Я в помещении», то P ↔ Q означает, что «Если идёт дождь, то я в помещении» и «Если я в помещении, то идёт дождь». Это означает, что мы можем вывести больше, чем с помощью простой импликации. Если P ложно, то Q тоже ложно; если дождя нет, мы знаем, что я тоже не в помещении.

| P     | Q     | P ↔ Q |
| :---- | :---- | :---- |
| ложь  | ложь  | истина |
| ложь  | истина | ложь  |
| истина | ложь  | ложь  |
| истина | истина | истина |

**Модель (Model)**

Модель — это присвоение значения истинности каждой пропозиции. Повторим, пропозиции — это утверждения о мире, которые могут быть истинными или ложными. Однако знания о мире представлены в значениях истинности этих пропозиций. Модель — это назначение истинностных значений, которое предоставляет информацию о мире.

Например, если P: «Идёт дождь», а Q: «Вторник», моделью может быть следующее назначение: {P = Истина, Q = Ложь}. Эта модель означает, что идет дождь, но сегодня не вторник. Однако в этой ситуации возможно больше моделей (например, {P = Истина, Q = Истина}, где идет дождь и вторник). Фактически, количество возможных моделей равно 2 в степени количества пропозиций. В этом случае у нас было 2 пропозиции, поэтому 2²=4 возможных модели.

**База знаний (Knowledge Base, KB)**

База знаний — это набор высказываний, известных агенту, основанному на знаниях. Это знания, которые предоставлены ИИ о мире в виде высказываний логики высказываний, которые можно использовать для получения дополнительных выводов о мире.

**Логическое следование (Entailment) (⊨)**

Если α ⊨ β (α влечёт β), то в любом мире, где α истинна, β также истинна.

Например, если α: «Сегодня вторник в январе», а β: «Сейчас январь», то мы знаем, что α ⊨ β. Если истинно, что сегодня вторник в январе, мы также знаем, что сейчас январь. Следование отличается от импликации. Импликация — это логическая связка между двумя пропозициями. Следование, с другой стороны, — это отношение, которое означает, что если вся информация в α истинна, то вся информация в β также истинна.

**Вывод (Inference)**
Вывод — это процесс вывода новых высказываний из старых.

Например, в примере с Гарри Поттером ранее высказывания 4 и 5 были выведены из высказываний 1, 2 и 3.

Существует несколько способов вывода новых знаний на основе существующих. Сначала мы рассмотрим алгоритм проверки моделей (Model Checking).

*   Чтобы определить, выполняется ли KB ⊨ α (другими словами, ответить на вопрос: «Можем ли мы заключить, что α истинно на основе нашей базы знаний?»)
    1.  Перечислить все возможные модели.
    2.  Если в каждой модели, где KB истинна, α также истинна, то KB влечёт α (KB ⊨ α).

Рассмотрим следующий пример:

P: Вторник. Q: Идёт дождь. R: Гарри пойдет на пробежку.
KB: (P ∧ ¬Q) → R (словами: P и не Q влекут R)
P (P истинно)
¬Q (Q ложно)
Запрос: R (Мы хотим знать, истинно R или ложно; Выполняется ли KB ⊨ R?)

Чтобы ответить на запрос с помощью алгоритма проверки моделей, мы перечисляем все возможные модели.

| P     | Q     | R     | KB    |
| :---- | :---- | :---- | :---- |
| ложь  | ложь  | ложь  |       |
| ложь  | ложь  | истина |       |
| ложь  | истина | ложь  |       |
| ложь  | истина | истина |       |
| истина | ложь  | ложь  |       |
| истина | ложь  | истина |       |
| истина | истина | ложь  |       |
| истина | истина | истина |       |

Затем мы проходим через каждую модель и проверяем, является ли она истинной с учетом нашей Базы Знаний.

Во-первых, в нашей KB мы знаем, что P истинно. Таким образом, мы можем сказать, что KB ложна во всех моделях, где P не истинно.

| P     | Q     | R     | KB    |
| :---- | :---- | :---- | :---- |
| ложь  | ложь  | ложь  | ложь  |
| ложь  | ложь  | истина | ложь  |
| ложь  | истина | ложь  | ложь  |
| ложь  | истина | истина | ложь  |
| истина | ложь  | ложь  |       |
| истина | ложь  | истина |       |
| истина | истина | ложь  |       |
| истина | истина | истина |       |

Далее, аналогично, в нашей KB мы знаем, что Q ложно. Таким образом, мы можем сказать, что KB ложна во всех моделях, где Q истинно.

| P     | Q     | R     | KB    |
| :---- | :---- | :---- | :---- |
| ложь  | ложь  | ложь  | ложь  |
| ложь  | ложь  | истина | ложь  |
| ложь  | истина | ложь  | ложь  |
| ложь  | истина | истина | ложь  |
| истина | ложь  | ложь  |       |
| истина | ложь  | истина |       |
| истина | истина | ложь  | ложь  |
| истина | истина | истина | ложь  |

Наконец, у нас осталось две модели. В обеих P истинно и Q ложно. В одной модели R истинно, в другой R ложно. Поскольку (P ∧ ¬Q) → R находится в нашей KB, мы знаем, что в случае, когда P истинно и Q ложно, R должно быть истинно. Таким образом, мы говорим, что наша KB ложна для модели, где R ложно, и истинна для модели, где R истинно.

| P     | Q     | R     | KB    |
| :---- | :---- | :---- | :---- |
| ложь  | ложь  | ложь  | ложь  |
| ложь  | ложь  | истина | ложь  |
| ложь  | истина | ложь  | ложь  |
| ложь  | истина | истина | ложь  |
| истина | ложь  | ложь  | ложь  |
| истина | ложь  | истина | истина |
| истина | истина | ложь  | ложь  |
| истина | истина | истина | ложь  |

Глядя на эту таблицу, есть только одна модель, где наша база знаний истинна. В этой модели мы видим, что R также истинно. По нашему определению логического следования, если R истинно во всех моделях, где KB истинна, то KB ⊨ R.

Теперь давайте посмотрим, как знания и логика могут быть представлены в виде кода.

```python
from logic import *

# Создаем новые классы, каждый из которых имеет имя или символ, представляющий каждую пропозицию.
rain = Symbol("rain")  # Идёт дождь.
hagrid = Symbol("hagrid")  # Гарри навестил Хагрида
dumbledore = Symbol("dumbledore")  # Гарри навестил Дамблдора

# Сохраняем высказывания в KB
knowledge = And(  # Начинаем с логической связки "And", потому что каждая пропозиция представляет знание, которое, как мы знаем, истинно.

    Implication(Not(rain), hagrid),  # ¬(Идёт дождь) → (Гарри навестил Хагрида)

    Or(hagrid, dumbledore),  # (Гарри навестил Хагрида) ∨ (Гарри навестил Дамблдора).

    Not(And(hagrid, dumbledore)),  # ¬(Гарри навестил Хагрида ∧ Гарри навестил Дамблдора) т.е. Гарри не навещал и Хагрида, и Дамблдора.

    dumbledore  # Гарри навестил Дамблдора. Обратите внимание, что в то время как предыдущие пропозиции содержали несколько символов со связками, это пропозиция, состоящая из одного символа. Это означает, что мы принимаем как факт, что в этой KB Гарри навестил Дамблдора.
)
```

Для работы алгоритма проверки моделей требуется следующая информация:

*   База знаний (Knowledge Base), которая будет использоваться для выводов
*   Запрос (query) — пропозиция, которая нас интересует, и мы хотим проверить, следует ли она из KB
*   Символы (symbols) — список всех символов (или атомарных пропозиций), используемых (в нашем случае это rain, hagrid и dumbledore)
*   Модель (model) — назначение значений истинности и лжи символам

Алгоритм проверки моделей выглядит следующим образом:

```python
def check_all(knowledge, query, symbols, model):

    # Если модель имеет назначение для каждого символа
    # (Логика ниже может быть немного confusing: мы начинаем со списка символов. Функция является рекурсивной, и каждый раз, когда она вызывает сама себя, она извлекает один символ из списка symbols и генерирует из него модели. Таким образом, когда список symbols пуст, мы знаем, что мы закончили генерацию моделей со всеми возможными назначениями истинности символов.)
    if not symbols:

        # Если база знаний истинна в модели, то запрос также должен быть истинным
        if knowledge.evaluate(model):
            return query.evaluate(model)
        return True
    else:

        # Выбираем один из оставшихся неиспользованных символов
        remaining = symbols.copy()
        p = remaining.pop()

        # Создаем модель, где символ истинен
        model_true = model.copy()
        model_true[p] = True

        # Создаем модель, где символ ложен
        model_false = model.copy()
        model_false[p] = False

        # Обеспечиваем, чтобы следование выполнялось в обеих моделях
        return(check_all(knowledge, query, remaining, model_true) and check_all(knowledge, query, remaining, model_false))
```

Обратите внимание, что мы интересуемся только моделями, где KB истинна. Если KB ложна, то условия, которые, как мы знаем, истинны, не выполняются в этих моделях, что делает их нерелевантными для нашего случая.

Пример извне лекции: Пусть P: Гарри играет ловцом, Q: Оливер играет вратарём, R: Гриффиндор выигрывает. Наша KB указывает, что P, Q и (P ∧ Q) → R. Другими словами, мы знаем, что P истинно, т.е. Гарри играет ловцом, и что Q истинно, т.е. Оливер играет вратарём, и что если и P, и Q истинны, то R тоже истинно, то есть Гриффиндор выигрывает матч. Теперь представьте модель, где Гарри играл загонщиком вместо ловца (таким образом, Гарри не играл ловцом, ¬P). Что ж, в этом случае нам не важно, выиграл ли Гриффиндор (истинно R или нет), потому что у нас есть информация в нашей KB, что Гарри играл ловцом, а не загонщиком. Мы интересуемся только моделями, где, как в нашем случае, P и Q истинны.)

Кроме того, функция `check_all` работает рекурсивно. То есть она выбирает один символ, создает две модели, в одной из которых символ истинен, а в другой ложен, а затем снова вызывает себя, теперь с двумя моделями, которые различаются назначением истинности этого символа. Функция будет продолжать делать это до тех пор, пока всем символам не будут присвоены значения истинности в моделях, оставив список `symbols` пустым. Как только он станет пустым (как определено строкой `if not symbols`), в каждом экземпляре функции (где каждый экземпляр содержит другую модель) функция проверяет, является ли KB истинной при данной модели. Если KB истинна в этой модели, функция проверяет, истинен ли запрос, как описано ранее.

**Инженерия знаний (Knowledge Engineering)**
Инженерия знаний — это процесс выяснения, как представить пропозиции и логику в ИИ.

Давайте попрактикуемся в инженерии знаний, используя игру «Clue» (напомним, в русской версии «Служенье духу убийства» или «Клуэдо»).

В игре убийство было совершено человеком с использованием инструмента в определенном месте. Люди, инструменты и места представлены карточками. Одна карточка из каждой категории выбирается случайным образом и помещается в конверт, и участники должны раскрыть, кто это сделал. Участники делают это, открывая карточки и выводя из этих подсказок, что должно быть в конверте. Мы будем использовать алгоритм проверки моделей, чтобы раскрыть тайну. В нашей модели мы помечаем как True элементы, которые, как мы знаем, связаны с убийством, и False в противном случае.

Для наших целей предположим, что у нас есть три человека: Мастард, Плам и Скарлет, три инструмента: нож, револьвер и гаечный ключ, и три места: бальный зал, кухня и библиотека.

Мы можем начать создавать нашу базу знаний, добавив правила игры. Мы знаем точно, что один человек — убийца, что был использован один инструмент и что убийство произошло в одном месте. Это можно представить в логике высказываний следующим образом:

(Мастард ∨ Плам ∨ Скарлет)
(нож ∨ револьвер ∨ гаечный ключ)
(бальный зал ∨ кухня ∨ библиотека)

Игра начинается с того, что каждый игрок видит одного человека, один инструмент и одно место, таким образом зная, что они не связаны с убийством. Игроки не делятся информацией, которую они видели на этих карточках. Предположим, наш игрок получает карточки Мастарда, кухни и револьвера. Таким образом, мы знаем, что они не связаны с убийством, и мы можем добавить в нашу KB

¬(Мастард)
¬(кухня)
¬(револьвер)

В других ситуациях в игре можно сделать предположение, предложив одну комбинацию человека, инструмента и места. Предположим, что предположение состоит в том, что Скарлет использовала гаечный ключ для совершения преступления в библиотеке. Если это предположение неверно, то можно вывести следующее и добавить в KB:

(¬Скарлет ∨ ¬библиотека ∨ ¬гаечный ключ)

Теперь предположим, что кто-то показал нам карточку Плама. Таким образом, мы можем добавить

¬(Плам)

в нашу KB.

На этом этапе мы можем заключить, что убийца — Скарлет, поскольку это должен быть один из Мастарда, Плама или Скарлет, и у нас есть доказательства, что первые два не являются им.

Добавление всего лишь одного дополнительного фрагмента знаний, например, что это не бальный зал, может дать нам больше информации. Сначала мы обновляем нашу KB

¬(бальный зал)

И теперь, используя несколько предыдущих данных, мы можем сделать вывод, что Скарлет совершила убийство ножом в библиотеке. Мы можем deduce, что это библиотека, потому что это должен быть либо бальный зал, либо кухня, либо библиотека, и первые два оказались не теми местами. Однако, когда кто-то предположил Скарлет, библиотека, гаечный ключ, предположение было ложным. Таким образом, по крайней мере один из элементов в этом утверждении должен быть ложным. Поскольку мы знаем, что и Скарлет, и библиотека истинны, мы знаем, что гаечный ключ является ложной частью. Поскольку один из трех инструментов должен быть истинным, и это не гаечный ключ и не револьвер, мы можем заключить, что это нож.

Вот как информация будет добавлена в базу знаний на Python:

```python
# Добавляем подсказки в KB
knowledge = And(

    # Начинаем с условий игры: один элемент в каждой из трех категорий должен быть истинным.
    Or(mustard, plum, scarlet),
    Or(ballroom, kitchen, library),
    Or(knife, revolver, wrench),

    # Добавляем информацию из трех初始льных карточек, которые мы видели
    Not(mustard),
    Not(kitchen),
    Not(revolver),

    # Добавляем предположение, которое сделал кто-то: это Скарлет, использовавшая гаечный ключ в библиотеке
    Or(Not(scarlet), Not(library), Not(wrench)),

    # Добавляем карточки, которые были нам показаны
    Not(plum),
    Not(ballroom)
)
```

Мы можем рассмотреть и другие логические головоломки. Рассмотрим следующий пример: четырем разным людям, Гилдерою, Помоне, Минерве и Горацию, назначены четыре разных факультета: Гриффиндор, Пуффендуй, Когтевран и Слизерин. На каждом факультете ровно один человек. Представление условий головоломки в логике высказываний довольно громоздко. Во-первых, каждое из возможных назначений должно быть само по себе пропозицией: МинерваГриффиндор, МинерваПуффендуй, МинерваКогтевран, МинерваСлизерин, ПомонаГриффиндор... Во-вторых, чтобы представить, что каждый человек принадлежит к факультету, требуется оператор Or со всеми возможными назначениями факультета на человека.

(МинерваГриффиндор ∨ МинерваПуффендуй ∨ МинерваКогтевран ∨ МинерваСлизерин), повторить для каждого человека.

Затем, чтобы закодировать, что если один человек назначен на один факультет, он не назначен на другие факультеты, мы напишем

(МинерваГриффиндор → ¬МинерваПуффендуй) ∧ (МинерваГриффиндор → ¬МинерваКогтевран) ∧ (МинерваГриффиндор → ¬МинерваСлизерин) ∧ (МинерваПуффендуй → ¬МинерваГриффиндор)…

и так далее для всех факультетов и всех людей. Решение этой неэффективности предлагается в разделе о логике первого порядка. Однако этот тип загадки все еще можно решить с помощью любого типа логики, при наличии достаточного количества подсказок.

Другой тип головоломки, которую можно решить с помощью логики высказываний, — это игра «Mastermind» («Брейккод» и др.). В этой игре первый игрок расставляет цвета в определенном порядке, а затем второй игрок должен угадать этот порядок. Каждый ход второй игрок делает предположение, а первый игрок возвращает число, указывающее, сколько цветов второй игрок угадал правильно. Давайте смоделируем игру с четырьмя цветами. Предположим, второй игрок предлагает следующий порядок:

![image](./.assets/image-1760818568233.png)
Первый игрок отвечает «два». Таким образом, мы знаем, что некоторые два цвета находятся в правильной позиции, а два других — в неправильном месте. Основываясь на этой информации, второй игрок пытается поменять местами два цвета.

![image](./.assets/image-1760818582165.png)

Теперь первый игрок отвечает «ноль». Таким образом, второй игрок знает, что поменянные цвета изначально были в правильном месте, а это значит, что нетронутые два цвета были в неправильном месте. Второй игрок меняет их местами.
Первый игрок говорит «четыре», и игра окончена.

![image](./.assets/image-1760818588907.png)

Представление этого в логике высказываний потребовало бы от нас наличия (количество цветов)² атомарных пропозиций. Итак, в случае четырех цветов у нас будут пропозиции red0, red1, red2, red3, blue0... означающие цвет и позицию. Следующим шагом будет представление правил игры в логике высказываний (что в каждой позиции только один цвет и цвета не повторяются) и добавление их в KB. Последним шагом будет добавление всех имеющихся у нас подсказок в KB. В нашем случае мы добавим, что при первом предположении две позиции были неправильными, а две — правильными, а при втором предположении ни одна не была правильной. Используя эти знания, алгоритм проверки моделей может дать нам решение головоломки.

**Правила вывода (Inference Rules)**
Проверка моделей не является эффективным алгоритмом, потому что она должна рассмотреть каждую возможную модель, прежде чем дать ответ (напоминание: запрос R истинен, если при всех моделях (назначениях истинности), где KB истинна, R также истинен). Правила вывода позволяют нам генерировать новую информацию на основе существующих знаний без рассмотрения каждой возможной модели.

Правила вывода обычно представляются с помощью горизонтальной черты, которая отделяет верхнюю часть, посылку (premise), от нижней части, заключение (conclusion). Посылка — это все знания, которые у нас есть, а заключение — это знания, которые могут быть сгенерированы на основе посылки.

![image](./.assets/image-1760818596141.png)

В этом примере наша посылка состоит из следующих пропозиций:

1.  Если идет дождь, то Гарри внутри.
2.  Идёт дождь.

Основываясь на этом, большинство разумных людей могут заключить, что

3.  Гарри внутри.

**Modus Ponens**

Тип правила вывода, который мы используем в этом примере, — это Modus Ponens, что является сложным способом сказать, что если мы знаем, что импликация и ее антецедент истинны, то консеквент также истинен.

![image](./.assets/image-1760818603098.png)

**Удаление И (And Elimination)**

Если пропозиция «И» истинна, то любая одна атомарная пропозиция внутри нее также истинна. Например, если мы знаем, что Гарри дружит с Роном и Гермионой, мы можем заключить, что Гарри дружит с Гермионой.

![image](./.assets/image-1760818608937.png)

**Удаление двойного отрицания (Double Negation Elimination)**

Пропозиция, которая отрицается дважды, истинна. Например, рассмотрим пропозицию «Неверно, что Гарри не сдал тест». Мы можем разобрать ее следующим образом: «Неверно, что (Гарри не сдал тест)», или «¬(Гарри не сдал тест)», и, наконец, «¬(¬(Гарри сдал тест))». Два отрицания компенсируют друг друга, помечая пропозицию «Гарри сдал тест» как истинную.

![image](./.assets/image-1760818615132.png)

**Удаление импликации (Implication Elimination)**

Импликация эквивалентна отношению «Или» между отрицанным антецедентом и консеквентом. В качестве примера, пропозиция «Если идет дождь, Гарри внутри» эквивалентна пропозиции «(дождя нет) или (Гарри внутри)».

![image](./.assets/image-1760818619859.png)

Это может быть немного confusing. Однако рассмотрим следующую таблицу истинности:

| P     | Q     | P → Q | ¬P ∨ Q |
| :---- | :---- | :---- | :----- |
| ложь  | ложь  | истина | истина |
| ложь  | истина | истина | истина |
| истина | ложь  | ложь  | ложь   |
| истина | истина | истина | истина |

Поскольку P → Q и ¬P ∨ Q имеют одинаковые назначения значений истинности, мы знаем, что они логически эквивалентны. Другой способ думать об этом заключается в том, что импликация истинна, если выполняется одно из двух возможных условий: во-первых, если антецедент ложен, импликация тривиально истинна (как обсуждалось ранее, в разделе об импликации). Это представлено отрицанным антецедентом P в ¬P ∨ Q, что означает, что пропозиция всегда истинна, если P ложен. Во-вторых, импликация истинна, когда антецедент истинен, только если консеквент также истинен. То есть, если и P, и Q истинны, то ¬P ∨ Q истинна. Однако, если P истинна, а Q нет, то ¬P ∨ Q ложна.

**Удаление бикондиционала (Biconditional Elimination)**

Бикондициональная пропозиция эквивалентна импликации и ее обратной с связкой «И». Например, «Идет дождь тогда и только тогда, когда Гарри внутри» эквивалентно («Если идет дождь, Гарри внутри» И «Если Гарри внутри, идет дождь»).

![image](./.assets/image-1760818631934.png)

**Законы Де Моргана (De Morgan’s Law)**

Можно превратить связку «И» в связку «Или». Рассмотрим следующую пропозицию: «Неверно, что и Гарри, и Рон сдали тест». Из этого можно заключить, что «Неверно, что Гарри сдал тест» Или «Неверно, что Рон сдал тест». То есть, для того чтобы предыдущая пропозиция «И» была истинной, по крайней мере одна из пропозиций в пропозициях «Или» должна быть истинной.

![image](./.assets/image-1760818636294.png)

Аналогично, можно заключить обратное. Рассмотрим пропозицию «Неверно, что Гарри или Рон сдали тест». Это можно перефразировать как «Гарри не сдал тест» И «Рон не сдал тест».

![image](./.assets/image-1760818639565.png)

**Дистрибутивность (Distributive Property)**

Пропозиция с двумя элементами, сгруппированными связками «И» или «Или», может быть распределена или разбита на меньшие единицы, состоящие из «И» и «Или».

![image](./.assets/image-1760818647097.png)

![image](./.assets/image-1760818651957.png)

**Знания и задачи поиска (Knowledge and Search Problems)**

Вывод можно рассматривать как задачу поиска со следующими свойствами:

*   Начальное состояние: начальная база знаний
*   Действия: правила вывода
*   Модель перехода: новая база знаний после вывода
*   Проверка цели: проверка, содержится ли утверждение, которое мы пытаемся доказать, в KB
*   Функция стоимости пути: количество шагов в доказательстве

Это показывает, насколько универсальны алгоритмы поиска, позволяя нам получать новую информацию на основе существующих знаний с помощью правил вывода.

**Резолюция (Resolution)**
Резолюция — это мощное правило вывода, которое гласит, что если одна из двух атомарных пропозиций в пропозиции «Или» ложна, другая должна быть истинной. Например, учитывая пропозицию «Рон в Большом зале» Или «Гермиона в библиотеке», в дополнение к пропозиции «Рона нет в Большом зале», мы можем заключить, что «Гермиона в библиотеке». Более формально, мы можем определить резолюцию следующим образом:

![image](./.assets/image-1760818668199.png)

`(P ∨ Q) ∧ (¬P) ⊨ Q`

Резолюция основана на **комплементарных литералах (Complementary Literals)**, двух одинаковых атомарных пропозициях, где одна отрицается, а другая нет, таких как P и ¬P.

Резолюцию можно further обобщить. Предположим, что в дополнение к пропозиции «Рон в Большом зале» Или «Гермиона в библиотеке» мы также знаем, что «Рона нет в Большом зале» Или «Гарри спит». Мы можем вывести из этого, используя резолюцию, что «Гермиона в библиотеке» Или «Гарри спит». Если выразить это в формальных терминах:

![image](./.assets/image-1760818676084.png)

`(P ∨ Q) ∧ (¬P ∨ R) ⊨ (Q ∨ R)`

Комплементарные литералы позволяют нам генерировать новые высказывания с помощью выводов путем резолюции. Таким образом, алгоритмы вывода находят комплементарные литералы для генерации новых знаний.

**Клауза (Clause)** — это дизъюнкция литералов (пропозициональный символ или отрицание пропозиционального символа, такой как P, ¬P). Дизъюнкция состоит из пропозиций, соединенных логической связкой «Или» (P ∨ Q ∨ R). Конъюнкция, с другой стороны, состоит из пропозиций, соединенных логической связкой «И» (P ∧ Q ∧ R). Клаузы позволяют нам преобразовать любое логическое высказывание в **Конъюнктивную нормальную форму (КНФ) (Conjunctive Normal Form, CNF)**, которая представляет собой конъюнкцию клауз, например: (A ∨ B ∨ C) ∧ (D ∨ ¬E) ∧ (F ∨ G).

**Шаги преобразования пропозиций в конъюнктивную нормальную форму**

1.  Устранить бикондиционалы
    Превратить (α ↔ β) в (α → β) ∧ (β → α).
2.  Устранить импликации
    Превратить (α → β) в ¬α ∨ β.
3.  Перенести отрицания внутрь до тех пор, пока отрицаются только литералы (а не клаузы), используя Законы Де Моргана.
    Превратить ¬(α ∧ β) в ¬α ∨ ¬β
    Превратить ¬(α ∨ β) в ¬α ∧ ¬β
4.  Применить дистрибутивность, чтобы получить конъюнкцию дизъюнктов (при необходимости).

Вот пример преобразования (P ∨ Q) → R в Конъюнктивную Нормальную Форму:

1.  (P ∨ Q) → R
2.  ¬(P ∨ Q) ∨ R /Устранить импликацию
3.  (¬P ∧ ¬Q) ∨ R /Законы Де Моргана
4.  (¬P ∨ R) ∧ (¬Q ∨ R) /Дистрибутивность

На этом этапе мы можем запустить алгоритм вывода на конъюнктивной нормальной форме. Иногда в процессе вывода путем резолюции мы можем оказаться в случаях, когда клауза содержит один и тот же литерал дважды. В этих случаях используется процесс, называемый **факторизацией (factoring)**, при котором удаляется дублирующийся литерал. Например, (P ∨ Q ∨ S) ∧ (¬P ∨ R ∨ S) позволяют нам вывести путем резолюции, что (Q ∨ S ∨ R ∨ S). Дублирующий S можно удалить, чтобы получить (Q ∨ R ∨ S).

Разрешение литерала и его отрицания, т.е. ¬P и P, дает пустую клаузу `()`. Пустая клауза всегда ложна, и это имеет смысл, потому что невозможно, чтобы и P, и ¬P были истинными. Этот факт используется алгоритмом резолюции.

Чтобы определить, выполняется ли KB ⊨ α:
1.  Проверить: является ли (KB ∧ ¬α) противоречием?
2.  Если да, то KB ⊨ α.
3.  В противном случае, следования нет.

**Доказательство от противного (Proof by contradiction)** — это инструмент, часто используемый в информатике. Если наша база знаний истинна и она противоречит ¬α, это означает, что ¬α ложно и, следовательно, α должно быть истинным. Более технически алгоритм выполнял бы следующие действия:

Чтобы определить, выполняется ли KB ⊨ α:
1.  Преобразовать (KB ∧ ¬α) в Конъюнктивную Нормальную Форму.
2.  Продолжать проверять, можем ли мы использовать резолюцию для создания новой клаузы.
3.  Если мы когда-нибудь получим пустую клаузу (эквивалентную Лжи), поздравляем! Мы пришли к противоречию, таким образом доказывая, что KB ⊨ α.
4.  Однако, если противоречие не достигнуто и больше нельзя вывести клауз, следования нет.

Вот пример, иллюстрирующий, как может работать этот алгоритм:

Выполняется ли (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ⊨ A?
1.  Сначала, чтобы доказать от противного, мы предполагаем, что A ложно. Таким образом, мы приходим к (A ∨ B) ∧ (¬B ∨ C) ∧ (¬C) ∧ (¬A).
2.  Теперь мы можем начать генерировать новую информацию. Поскольку мы знаем, что C ложно (¬C), единственный способ, которым (¬B ∨ C) может быть истинным, — это если B тоже ложно. Таким образом, мы можем добавить (¬B) в нашу KB.
3.  Далее, поскольку мы знаем (¬B), единственный способ, которым (A ∨ B) может быть истинным, — это если A истинно. Таким образом, мы можем добавить (A) в нашу KB.
4.  Теперь наша KB имеет два комплементарных литерала, (A) и (¬A). Мы разрешаем их, получая пустое множество, `()`. Пустое множество по определению ложно, поэтому мы пришли к противоречию.

**Логика первого порядка (First Order Logic)**
Логика первого порядка — это другой тип логики, который позволяет нам выражать более сложные идеи более лаконично, чем логика высказываний. Логика первого порядка использует два типа символов: **Символы констант (Constant Symbols)** и **Символы предикатов (Predicate Symbols)**. Символы констант представляют объекты, в то время как символы предикатов похожи на отношения или функции, которые принимают аргумент и возвращают значение истинности или лжи.

Например, мы возвращаемся к логической головоломке с разными людьми и назначениями на факультеты в Хогвартсе. Символы констант — это люди или факультеты, такие как Минерва, Помона, Гриффиндор, Пуффендуй и т.д. Символы предикатов — это свойства, которые выполняются (true или false) для некоторых символов констант. Например, мы можем выразить идею, что Минерва — это человек, с помощью высказывания `Person(Минерва)`. Аналогично, мы можем выразить идею, что Гриффиндор — это факультет, с помощью высказывания `House(Гриффиндор)`. Все логические связки работают в логике первого порядка так же, как и раньше. Например, `¬House(Минерва)` выражает идею, что Минерва не является факультетом. Символ предиката также может принимать два или более аргументов и выражать отношение между ними. Например, `BelongsTo` выражает отношение между двумя аргументами, человеком и факультетом, к которому этот человек принадлежит. Таким образом, идея, что Минерва принадлежит Гриффиндору, может быть выражена как `BelongsTo(Минерва, Гриффиндор)`. Логика первого порядка позволяет иметь один символ для каждого человека и один символ для каждого факультета. Это более лаконично, чем логика высказываний, где для каждого назначения человек-факультет потребовался бы отдельный символ.

**Универсальная квантификация (Universal Quantification)**

Квантификация — это инструмент, который можно использовать в логике первого порядка для представления высказываний без использования конкретного символа константы. Универсальная квантификация использует символ `∀` для выражения «для всех». Так, например, высказывание `∀x. BelongsTo(x, Гриффиндор) → ¬BelongsTo(x, Пуффендуй)` выражает идею, что для каждого символа истинно, что если этот символ принадлежит Гриффиндору, то он не принадлежит Пуффендую.

**Экзистенциальная квантификация (Existential Quantification)**

Экзистенциальная квантификация — это идея, параллельная универсальной квантификации. Однако в то время как универсальная квантификация использовалась для создания высказываний, истинных для всех x, экзистенциальная квантификация используется для создания высказываний, истинных по крайней мере для одного x. Она выражается с помощью символа `∃`. Например, высказывание `∃x. House(x) ∧ BelongsTo(Минерва, x)` означает, что существует по крайней мере один символ, который является и факультетом, и Минерва принадлежит ему. Другими словами, это выражает идею, что Минерва принадлежит к какому-то факультету.

Экзистенциальная и универсальная квантификация могут быть использованы в одном высказывании. Например, высказывание `∀x. Person(x) → (∃y. House(y) ∧ BelongsTo(x, y))` выражает идею, что если x — это человек, то существует по крайней мере один факультет y, к которому этот человек принадлежит. Другими словами, это высказывание означает, что каждый человек принадлежит к какому-то факультету.

Существуют и другие типы логики, и общность между ними заключается в том, что все они существуют для представления информации. Это системы, которые мы используем для представления знаний в нашем ИИ.