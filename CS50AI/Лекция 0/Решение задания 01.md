# Решение задания 01
поиск связей
```py
def shortest_path(source, target):
    """
    Returns the shortest list of (movie_id, person_id) pairs
    that connect the source to the target.

    If no possible path, returns None.
    """

    # Инициализируем границу (frontier) с помощью QueueFrontier для BFS
    # Начальный узел содержит исходного человека (source)
    # У него нет родителя (parent=None) и действия (action=None)
    start_node = Node(state=source, parent=None, action=None)
    frontier = QueueFrontier()
    frontier.add(start_node)

    # Создаем пустое множество 'explored' для отслеживания уже посещенных людей
    # Это нужно, чтобы избежать циклов и повторной работы
    explored = set()

    # Начинаем цикл поиска
    while True:

        # Если граница пуста, значит, мы исследовали все достижимые узлы
        # и не нашли путь к цели.
        if frontier.empty():
            return None

        # Извлекаем узел из границы.
        # Так как это QueueFrontier, мы получаем самый старый узел (FIFO),
        # что и обеспечивает поиск в ширину.
        node = frontier.remove()

        # Проверяем, является ли состояние (person_id) этого узла нашей целью
        if node.state == target:
            # Цель найдена!
            # Теперь нужно восстановить путь, двигаясь обратно от цели к источнику
            # по родительским узлам (parent).
            path = []
            
            # Двигаемся "вверх" по дереву поиска, пока не дойдем до
            # начального узла (у которого parent == None)
            while node.parent is not None:
                # Каждый шаг на пути — это (movie_id, person_id)
                # node.action хранит movie_id
                # node.state хранит person_id
                path.append((node.action, node.state))
                node = node.parent
            
            # Мы построили путь от цели к источнику,
            # поэтому его нужно развернуть
            path.reverse()
            return path

        # Если это не цель, добавляем текущего человека в 'explored'
        # чтобы не проверять его снова
        explored.add(node.state)

        # Получаем всех "соседей" (co-stars) для текущего человека
        # neighbors_for_person возвращает множество кортежей (movie_id, person_id)
        neighbors = neighbors_for_person(node.state)

        # Перебираем всех соседей
        for movie_id, person_id in neighbors:
            
            # Проверяем, что мы еще не исследовали этого соседа
            # И что он не находится уже в очереди (границе)
            if person_id not in explored and not frontier.contains_state(person_id):
                
                # Создаем новый узел для этого соседа
                # Его 'parent' - это текущий узел 'node'
                # Его 'action' - это movie_id, который их связывает
                child_node = Node(state=person_id, parent=node, action=movie_id)
                
                # Добавляем новый узел в границу для дальнейшего исследования
                frontier.add(child_node)
```