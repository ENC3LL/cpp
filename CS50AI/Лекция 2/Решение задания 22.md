# Решение задания 22

### Heredity (heredity.py)

### Общее пояснение

Этот файл использует Байесовскую сеть для расчета генетических вероятностей. У каждого человека есть "скрытое" состояние (0, 1 или 2 копии гена) и "наблюдаемое" состояние (есть признак или нет).

Программа вычисляет условные вероятности:

1. **P(Гены | Данные)**: Вероятность того, что у человека 0, 1 или 2 копии гена, *учитывая* известные данные о признаках у всех членов семьи.
2. **P(Признак | Данные)**: Вероятность того, проявит ли человек признак, *учитывая* те же данные.

Для этого `main` перебирает *все возможные миры* (все комбинации генов и признаков у всех людей).

1. `joint_probability` вычисляет совместную вероятность P(Гены, Признаки) для одного такого "мира".
2. `update` суммирует эти вероятности в соответствующие "корзины" (например, в `probabilities["Harry"]["gene"][1]`).
3. `normalize` преобразует эти суммы в итоговые вероятности, приводя сумму по каждой категории (гены, признаки) к 1.

### Код

```py
import csv
import itertools
import sys

# PROBS - Словарь, хранящий все базовые вероятности
PROBS = {

    # Безусловная вероятность наличия гена (если о родителях ничего не известно)
    "gene": {
        2: 0.01,  # 1% шанс иметь 2 копии гена
        1: 0.03,  # 3% шанс иметь 1 копию
        0: 0.96   # 96% шанс не иметь копий
    },

    "trait": {
        # P(Признак | Гены) - Условная вероятность проявления признака
        
        # Вероятность признака при 2 копиях гена
        2: {
            True: 0.65,  # 65% шанс проявить признак
            False: 0.35  # 35% шанс НЕ проявить
        },

        # Вероятность признака при 1 копии гена
        1: {
            True: 0.56,
            False: 0.44
        },

        # Вероятность признака при 0 копиях гена
        0: {
            True: 0.01,  # 1% шанс проявить признак (например, из-за других факторов)
            False: 0.99  # 99% шанс НЕ проявить
        }
    },

    # Вероятность мутации при передаче гена от родителя к ребенку
    "mutation": 0.01
}


def main():

    # Проверка правильности использования
    if len(sys.argv) != 2:
        sys.exit("Usage: python heredity.py data.csv")
    people = load_data(sys.argv[1]) # Загрузка данных из CSV

    # Словарь для хранения ИТОГОВЫХ вероятностей для каждого человека
    # Изначально все счетчики равны 0
    probabilities = {
        person: {
            "gene": {
                2: 0,
                1: 0,
                0: 0
            },
            "trait": {
                True: 0,
                False: 0
            }
        }
        for person in people
    }

    # --- Главный цикл: Перебор всех "возможных миров" ---
    
    names = set(people)
    
    # 1. Перебираем все возможные комбинации того, у кого ЕСТЬ признак
    #    (powerset - множество всех подмножеств)
    for have_trait in powerset(names):

        # Проверяем, не противоречит ли этот "мир" известным данным.
        # (Например, в CSV сказано trait=1, а в `have_trait` человека нет)
        fails_evidence = any(
            (people[person]["trait"] is not None and
             people[person]["trait"] != (person in have_trait))
            for person in names
        )
        if fails_evidence:
            continue # Пропускаем этот невозможный "мир"

        # 2. Внутри: Перебираем, у кого 1 копия гена
        for one_gene in powerset(names):
            # 3. Внутри: Перебираем, у кого 2 копии гена
            #    (из тех, у кого нет 1 копии)
            for two_genes in powerset(names - one_gene):
                # (Те, кто не в `one_gene` и не в `two_genes`, автоматом
                #  получают 0 копий гена)
                
                # `p` - это совместная вероятность (joint probability)
                # этого ОДНОГО КОНКРЕТНОГО "мира".
                p = joint_probability(people, one_gene, two_genes, have_trait)
                
                # Добавляем эту вероятность `p` к общим "счетчикам"
                # для каждого человека.
                update(probabilities, one_gene, two_genes, have_trait, p)

    # Нормализуем счетчики, чтобы получить итоговые вероятности
    normalize(probabilities)

    # Печать результатов
    for person in people:
        print(f"{person}:")
        for field in probabilities[person]:
            print(f"  {field.capitalize()}:")
            for value in probabilities[person][field]:
                p = probabilities[person][field][value]
                print(f"    {value}: {p:.4f}")


def load_data(filename):
    """
    Загружает данные о генах и признаках из CSV-файла в словарь.
    """
    data = dict()
    with open(filename) as f:
        reader = csv.DictReader(f)
        for row in reader:
            name = row["name"]
            data[name] = {
                "name": name,
                "mother": row["mother"] or None,
                "father": row["father"] or None,
                "trait": (True if row["trait"] == "1" else
                          False if row["trait"] == "0" else None)
            }
    return data


def powerset(s):
    """
    Возвращает список всех возможных подмножеств (булеан) множества s.
    Например, powerset({"A", "B"}) -> {frozenset(), frozenset({'B'}), frozenset({'A'}), frozenset({'A', 'B'})}
    """
    s = list(s)
    return [
        set(s) for s in itertools.chain.from_iterable(
            itertools.combinations(s, r) for r in range(len(s) + 1)
        )
    ]


def get_pass_probability(parent_genes):
    """
    Вспомогательная функция.
    Рассчитывает вероятность, что родитель с `parent_genes` генами
    передаст ребенку ОДНУ копию гена (с учетом мутаций).
    """
    if parent_genes == 0:
        # У родителя 0 генов. Он передаст ген, только если он мутирует.
        return PROBS["mutation"]
    elif parent_genes == 1:
        # У родителя 1 ген. 
        # Шанс 0.5 передать ген (и он НЕ мутирует)
        # Шанс 0.5 НЕ передать ген (но он мутирует)
        # p = 0.5 * (1 - PROBS["mutation"]) + 0.5 * PROBS["mutation"]
        # Это упрощается до 0.5
        return 0.5
    else: # parent_genes == 2
        # У родителя 2 гена. Он всегда передает ген,
        # если только он НЕ мутирует.
        return 1 - PROBS["mutation"]


def joint_probability(people, one_gene, two_genes, have_trait):
    """
    Вычисляет и возвращает совместную вероятность P(гены всех, признаки всех)
    для одного конкретного "мира", заданного аргументами.
    """
    joint_p = 1.0 # Начинаем с 1.0 и перемножаем вероятности

    for person in people:
        # 1. Определяем состояние этого человека в этом "мире"
        num_genes = 2 if person in two_genes else (1 if person in one_gene else 0)
        has_trait = person in have_trait

        mother = people[person]["mother"]
        father = people[person]["father"]
        
        gene_prob = 0 # Вероятность P(человек имеет `num_genes`)
        
        # 2. Рассчитываем P(gene)
        
        # Случай 1: У человека нет родителей в данных
        if mother is None:
            # Используем безусловную вероятность из PROBS["gene"]
            gene_prob = PROBS["gene"][num_genes]
        
        # Случай 2: У человека есть родители
        else:
            # Определяем, сколько генов у родителей в этом "мире"
            mother_genes = 2 if mother in two_genes else (1 if mother in one_gene else 0)
            father_genes = 2 if father in two_genes else (1 if father in one_gene else 0)
            
            # Вероятность получить ген от матери/отца
            p_from_mother = get_pass_probability(mother_genes)
            p_from_father = get_pass_probability(father_genes)
            
            # Вероятность НЕ получить ген
            p_not_from_mother = 1 - p_from_mother
            p_not_from_father = 1 - p_from_father

            # Рассчитываем вероятность `num_genes` у ребенка
            if num_genes == 0:
                # НЕ получить от матери И НЕ получить от отца
                gene_prob = p_not_from_mother * p_not_from_father
            elif num_genes == 1:
                # (Получить от матери И НЕ от отца) ИЛИ (НЕ от матери И от отца)
                gene_prob = (p_from_mother * p_not_from_father) + (p_not_from_mother * p_from_father)
            else: # num_genes == 2
                # Получить от матери И получить от отца
                gene_prob = p_from_mother * p_from_father
        
        # 3. Рассчитываем P(trait | gene)
        # Вероятность `has_trait` при условии `num_genes`
        trait_prob = PROBS["trait"][num_genes][has_trait]
        
        # 4. Включаем вероятности этого человека в общую совместную вероятность
        # P(A, B) = P(A) * P(B)
        joint_p *= gene_prob * trait_prob
        
    return joint_p


def update(probabilities, one_gene, two_genes, have_trait, p):
    """
    Добавляет совместную вероятность `p` этого "мира"
    к счетчикам для каждого человека в `probabilities`.
    """
    for person in probabilities:
        # Определяем состояние человека в этом "мире"
        num_genes = 2 if person in two_genes else (1 if person in one_gene else 0)
        has_trait = person in have_trait
        
        # Добавляем `p` к соответствующим "ячейкам"
        probabilities[person]["gene"][num_genes] += p
        probabilities[person]["trait"][has_trait] += p


def normalize(probabilities):
    """
    Обновляет `probabilities`, нормализуя каждое распределение
    (сумма должна стать 1, пропорции сохраняются).
    """
    for person in probabilities:
        # --- Нормализация "gene" ---
        # Считаем общую сумму для P(gene=0) + P(gene=1) + P(gene=2)
        gene_sum = sum(probabilities[person]["gene"].values())
        if gene_sum > 0:
            # Делим каждое значение на сумму, чтобы их
            # новая сумма стала равна 1
            for i in range(3):
                probabilities[person]["gene"][i] /= gene_sum
        
        # --- Нормализация "trait" ---
        # Считаем общую сумму для P(trait=True) + P(trait=False)
        trait_sum = sum(probabilities[person]["trait"].values())
        if trait_sum > 0:
            # Делим каждое значение на сумму
            probabilities[person]["trait"][True] /= trait_sum
            probabilities[person]["trait"][False] /= trait_sum


if __name__ == "__main__":
    main()
```