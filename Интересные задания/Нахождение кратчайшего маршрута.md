# Нахождение кратчайшего маршрута

Задача. Известны расстояния от почтамта до районных отделений связи и расстояния 
между отделениями связи. Почта поступает сначала на почтамт, а потом развозится по 
отделениям связи. Составьте маршрут машины, развозящей почту от почтамта до каждого 
отделения связи, чтобы ее путь был наименьшим, при этом она должна вернуться на 
почтамт. 
Расстояния между П (почтамтом) и ОС (отделениями связи, заданными номерами): 
П‐1 — 5км,П‐2— 3км, П‐3 — 4км, П‐4 — 4км. 
1‐2 — 3км, 1‐3 — 5км, 1‐4 — 6км. 
2‐3 — 4км, 2‐4 — 7км. 
3‐4 — 7км. 
Для нахождения искомого маршрута построить неориентированный граф, изобразить его 
на рисунке и, используя алгоритм Дейкстры, составить программу, находящую требуемый 
маршрут. 

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
#include <string>

using namespace std;

const int INF = numeric_limits<int>::max();

class Graph {
private:
    int vertices;
    vector<vector<int>> adjMatrix;

    // Вспомогательная функция для алгоритма Дейкстры
    vector<int> dijkstra(int start) {
        vector<int> dist(vertices, INF);
        vector<bool> visited(vertices, false);

        dist[start] = 0;

        for (int i = 0; i < vertices - 1; i++) {
            int minDist = INF;
            int minVertex = -1;

            // Находим вершину с минимальным расстоянием
            for (int v = 0; v < vertices; v++) {
                if (!visited[v] && dist[v] < minDist) {
                    minDist = dist[v];
                    minVertex = v;
                }
            }

            if (minVertex == -1) break;
            visited[minVertex] = true;

            // Обновляем расстояния до соседних вершин
            for (int v = 0; v < vertices; v++) {
                if (!visited[v] && adjMatrix[minVertex][v] != INF &&
                    dist[minVertex] != INF &&
                    dist[minVertex] + adjMatrix[minVertex][v] < dist[v]) {
                    dist[v] = dist[minVertex] + adjMatrix[minVertex][v];
                }
            }
        }

        return dist;
    }

public:
    Graph(int v) : vertices(v), adjMatrix(v, vector<int>(v, INF)) {
        for (int i = 0; i < v; i++) {
            adjMatrix[i][i] = 0;
        }
    }

    void addEdge(int u, int v, int weight) {
        adjMatrix[u][v] = weight;
        adjMatrix[v][u] = weight;
    }

    // Получаем матрицу кратчайших расстояний между всеми вершинами
    vector<vector<int>> getAllPairsShortestPaths() {
        vector<vector<int>> shortestPaths(vertices, vector<int>(vertices));

        for (int i = 0; i < vertices; i++) {
            vector<int> dist = dijkstra(i);
            shortestPaths[i] = dist;
        }

        return shortestPaths;
    }

    // Решаем задачу коммивояжера полным перебором
    pair<vector<int>, int> solveTSP(int start) {
        vector<vector<int>> distMatrix = getAllPairsShortestPaths();

        // Создаем список вершин для посещения (все кроме стартовой)
        vector<int> cities;
        for (int i = 0; i < vertices; i++) {
            if (i != start) {
                cities.push_back(i);
            }
        }

        vector<int> bestRoute;
        int minDistance = INF;

        // Перебираем все перестановки
        do {
            int currentDistance = 0;
            int currentCity = start;

            // Добавляем стартовую вершину в маршрут
            vector<int> currentRoute = { start };

            // Проходим по всем городам в текущей перестановке
            for (int city : cities) {
                currentDistance += distMatrix[currentCity][city];
                currentCity = city;
                currentRoute.push_back(city);
            }

            // Возвращаемся к стартовой вершине
            currentDistance += distMatrix[currentCity][start];
            currentRoute.push_back(start);

            // Обновляем лучший маршрут
            if (currentDistance < minDistance) {
                minDistance = currentDistance;
                bestRoute = currentRoute;
            }

        } while (next_permutation(cities.begin(), cities.end()));

        return { bestRoute, minDistance };
    }

    void printGraph() {
        cout << "Matrix:" << endl;
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                if (adjMatrix[i][j] == INF) {
                    cout << "INF\t";
                }
                else {
                    cout << adjMatrix[i][j] << "\t";
                }
            }
            cout << endl;
        }
    }
};

int main() {
    // Создаем граф с 5 вершинами (0-почтамт, 1-4 - отделения связи)
    Graph g(5);

    // Добавляем ребра согласно заданию
    g.addEdge(0, 1, 5); // П-1
    g.addEdge(0, 2, 3); // П-2
    g.addEdge(0, 3, 4); // П-3
    g.addEdge(0, 4, 4); // П-4

    g.addEdge(1, 2, 3); // 1-2
    g.addEdge(1, 3, 5); // 1-3
    g.addEdge(1, 4, 6); // 1-4

    g.addEdge(2, 3, 4); // 2-3
    g.addEdge(2, 4, 7); // 2-4

    g.addEdge(3, 4, 7); // 3-4

    cout << "Route graph:" << endl;
    g.printGraph();

    // Решаем задачу коммивояжера
    auto result = g.solveTSP(0);
    vector<int> bestRoute = result.first;
    int minDistance = result.second;

    // Выводим результат
    cout << "\nOptimal route: ";
    vector<string> vertexNames = { "P", "1", "2", "3", "4" };
    for (int i = 0; i < bestRoute.size(); i++) {
        cout << vertexNames[bestRoute[i]];
        if (i < bestRoute.size() - 1) {
            cout << " -> ";
        }
    }

    cout << "\nRoute: " << minDistance << " km" << endl;

    return 0;
}
```


Это код для решения задачи коммивояжера (TSP) с использованием алгоритма Дейкстры и полного перебора. Разберем по частям:

## Структура программы

### 1. Константы и класс Graph
```cpp
const int INF = numeric_limits<int>::max(); // "Бесконечность" для непосещенных вершин

class Graph {
private:
    int vertices; // Количество вершин
    vector<vector<int>> adjMatrix; // Матрица смежности
```
- `INF` представляет недостижимые вершины
- Матрица смежности хранит веса ребер

### 2. Алгоритм Дейкстры
```cpp
vector<int> dijkstra(int start) {
    vector<int> dist(vertices, INF); // Расстояния от стартовой вершины
    vector<bool> visited(vertices, false); // Посещенные вершины
    
    dist[start] = 0; // Расстояние до себя = 0
    
    for (int i = 0; i < vertices - 1; i++) {
        // Находим непосещенную вершину с минимальным расстоянием
        int minVertex = -1;
        for (int v = 0; v < vertices; v++) {
            if (!visited[v] && (minVertex == -1 || dist[v] < dist[minVertex]))
                minVertex = v;
        }
        
        if (dist[minVertex] == INF) break;
        visited[minVertex] = true;
        
        // Обновляем расстояния до соседей
        for (int v = 0; v < vertices; v++) {
            if (adjMatrix[minVertex][v] != INF) {
                dist[v] = min(dist[v], dist[minVertex] + adjMatrix[minVertex][v]);
            }
        }
    }
    return dist;
}
```

**Почему так:** Классическая реализация Дейкстры для плотных графов через матрицу смежности.

### 3. Решение задачи коммивояжера
```cpp
pair<vector<int>, int> solveTSP(int start) {
    vector<vector<int>> distMatrix = getAllPairsShortestPaths();
    
    vector<int> cities;
    for (int i = 0; i < vertices; i++) {
        if (i != start) cities.push_back(i);
    }
    
    vector<int> bestRoute;
    int minDistance = INF;
    
    // Полный перебор всех перестановок
    do {
        int currentDistance = 0;
        int currentCity = start;
        vector<int> currentRoute = {start};
        
        for (int city : cities) {
            currentDistance += distMatrix[currentCity][city];
            currentCity = city;
            currentRoute.push_back(city);
        }
        
        // Возврат к стартовой точке
        currentDistance += distMatrix[currentCity][start];
        currentRoute.push_back(start);
        
        if (currentDistance < minDistance) {
            minDistance = currentDistance;
            bestRoute = currentRoute;
        }
        
    } while (next_permutation(cities.begin(), cities.end()));
    
    return {bestRoute, minDistance};
}
```

**Почему именно так:**
- Сначала вычисляются кратчайшие пути между всеми парами вершин
- Затем перебираются все возможные маршруты через `next_permutation`
- Для каждого маршрута вычисляется общая длина
- Выбирается маршрут с минимальной длиной

### 4. Особенности реализации

**Почему используется Дейкстра перед TSP:**
- Граф может быть неполным
- Нужны кратчайшие пути между всеми вершинами, даже если нет прямого ребра
- Обеспечивает оптимальные маршруты между любыми точками

**Почему полный перебор:**
- Для 5 вершин (4 города кроме почтамта) всего 4! = 24 перестановки
- Это эффективно для небольших графов
- Гарантирует нахождение оптимального решения

### 5. Входные данные
```
Почтамт (0) соединен:
- с отделением 1: 5 км
- с отделением 2: 3 км  
- с отделением 3: 4 км
- с отделением 4: 4 км

Отделения соединены между собой:
1-2: 3 км, 1-3: 5 км, 1-4: 6 км
2-3: 4 км, 2-4: 7 км
3-4: 7 км
```

**Алгоритм найдет самый короткий маршрут,** который начинается и заканчивается в почтамте, посещая все отделения ровно по одному разу.

Сложность: O(V³) для Дейкстры всех пар + O((V-1)!) для перебора перестановок.