# Бинарный поиск в отсортированном векторе

Если вектор отсортирован, поиск элемента можно выполнить гораздо быстрее (за O(logN)), чем линейный поиск (`std::find`, O(N)).

* `std::binary_search`: Возвращает `true` или `false`, если элемент найден.
* `std::lower_bound`: Возвращает итератор на первый элемент, который **не меньше** заданного.
* `std::upper_bound`: Возвращает итератор на первый элемент, который **строго больше** заданного.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> vec(10);
    // Заполним вектор числами 0, 10, 20, ..., 90
    std::iota(vec.begin(), vec.end(), 0);
    for(auto& val : vec) val *= 10;

    std::cout << "Отсортированный вектор: ";
    for (int el : vec) std::cout << el << " ";
    std::cout << std::endl;

    int value_to_search;
    std::cout << "Введите значение для поиска: ";
    std::cin >> value_to_search;

    // Простая проверка наличия
    if (std::binary_search(vec.begin(), vec.end(), value_to_search)) {
        std::cout << "Элемент " << value_to_search << " присутствует в векторе." << std::endl;
        
        // Поиск позиции
        auto it_lower = std::lower_bound(vec.begin(), vec.end(), value_to_search);
        long long index = std::distance(vec.begin(), it_lower);
        std::cout << "lower_bound нашел его на позиции: " << index << std::endl;

    } else {
        std::cout << "Элемент " << value_to_search << " отсутствует." << std::endl;

        // Куда бы его можно было вставить, не нарушая порядок?
        auto it_upper = std::upper_bound(vec.begin(), vec.end(), value_to_search);
        long long insert_pos = std::distance(vec.begin(), it_upper);
        std::cout << "Его можно было бы вставить на позицию " << insert_pos << " для сохранения сортировки." << std::endl;
    }

    return 0;
}
```

