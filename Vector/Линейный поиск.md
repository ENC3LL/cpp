# Линейный поиск


## Базовый линейный поиск (возвращает индекс)

```cpp
#include <iostream>
#include <vector>
using namespace std;

int linearSearch(const vector<int>& vec, int target) {
    for (int i = 0; i < vec.size(); i++) {
        if (vec[i] == target) {
            return i; // Найден, возвращаем индекс
        }
    }
    return -1; // Не найден
}

int main() {
    vector<int> vec = {5, 2, 8, 1, 9, 3};
    int target = 8;
    
    int index = linearSearch(vec, target);
    
    if (index != -1) {
        cout << "Элемент " << target << " найден на позиции " << index << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    return 0;
}
```

## Поиск с использованием итераторов

```cpp
#include <iostream>
#include <vector>
using namespace std;

auto linearSearch(const vector<int>& vec, int target) {
    for (auto it = vec.begin(); it != vec.end(); it++) {
        if (*it == target) {
            return it; // Возвращаем итератор на найденный элемент
        }
    }
    return vec.end(); // Не найден
}

int main() {
    vector<int> vec = {5, 2, 8, 1, 9, 3};
    int target = 8;
    
    auto result = linearSearch(vec, target);
    
    if (result != vec.end()) {
        cout << "Элемент " << target << " найден на позиции " 
             << distance(vec.begin(), result) << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    return 0;
}
```

## Поиск всех вхождений

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> findAllOccurrences(const vector<int>& vec, int target) {
    vector<int> indices;
    for (int i = 0; i < vec.size(); i++) {
        if (vec[i] == target) {
            indices.push_back(i);
        }
    }
    return indices;
}

int main() {
    vector<int> vec = {5, 2, 8, 2, 9, 2, 3};
    int target = 2;
    
    vector<int> positions = findAllOccurrences(vec, target);
    
    if (!positions.empty()) {
        cout << "Элемент " << target << " найден на позициях: ";
        for (int pos : positions) {
            cout << pos << " ";
        }
        cout << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    return 0;
}
```

## Универсальный шаблонный поиск

```cpp
#include <iostream>
#include <vector>
using namespace std;

template<typename T>
int linearSearch(const vector<T>& vec, const T& target) {
    for (int i = 0; i < vec.size(); i++) {
        if (vec[i] == target) {
            return i;
        }
    }
    return -1;
}

int main() {
    vector<int> intVec = {1, 2, 3, 4, 5};
    vector<string> strVec = {"apple", "banana", "cherry"};
    
    cout << linearSearch(intVec, 3) << endl;    // 2
    cout << linearSearch(strVec, string("banana")) << endl; // 1
    
    return 0;
}
```

## Поиск с использованием стандартной библиотеки

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> vec = {5, 2, 8, 1, 9, 3};
    int target = 8;
    
    // Использование find из algorithm
    auto it = find(vec.begin(), vec.end(), target);
    
    if (it != vec.end()) {
        int index = distance(vec.begin(), it);
        cout << "Элемент " << target << " найден на позиции " << index << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
    return 0;
}
```

## Поиск с вводом данных от пользователя

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    cout << "Введите размер вектора: ";
    cin >> n;
    
    vector<int> vec(n);
    cout << "Введите элементы вектора: ";
    for (int i = 0; i < n; i++) {
        cin >> vec[i];
    }
    
    int target;
    cout << "Введите элемент для поиска: ";
    cin >> target;
    
    bool found = false;
    for (int i = 0; i < n; i++) {
        if (vec[i] == target) {
            cout << "Элемент найден на позиции " << i << endl;
            found = true;
            break; // Убираем break, если хотим найти все вхождения
        }
    }
    
    if (!found) {
        cout << "Элемент не найден" << endl;
    }
    
    return 0;
}
```

## Характеристики линейного поиска:

- **Временная сложность**: O(n) - в худшем случае
- **Пространственная сложность**: O(1) - не требует дополнительной памяти
- **Преимущества**: Прост в реализации, работает с неотсортированными данными
- **Недостатки**: Медленный для больших массивов

Для отсортированных векторов лучше использовать **бинарный поиск** (временная сложность O(log n)).