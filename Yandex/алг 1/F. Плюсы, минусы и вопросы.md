# F. Плюсы, минусы и вопросы


![image](./.assets/image-1759440522873.png)

# Ответ

```cpp
// --- ПОДКЛЮЧЕНИЕ НЕОБХОДИМЫХ БИБЛИОТЕК ---

#include <iostream>     // Для работы с вводом-выводом (cin, cout)
#include <vector>       // Для использования динамических массивов (vector)
#include <string>       // Для работы со строками (string)
#include <algorithm>    // Для использования стандартных алгоритмов, например, max/min (хотя в этой версии они не используются, но полезны)
#include <climits>      // Для доступа к предельным значениям типов данных, например, LLONG_MIN (минимальное значение long long)

using namespace std;    // Используем стандартное пространство имен, чтобы не писать std:: перед cin, cout, vector и т.д.

int main() {
    // --- ОПТИМИЗАЦИЯ ВВОДА-ВЫВОДА ---
    // Эти строки ускоряют работу cin и cout, что важно для больших объемов данных.
    ios_base::sync_with_stdio(false); // Отключает синхронизацию потоков C++ и C
    cin.tie(NULL);                    // Отвязывает cin от cout

    // --- ЧТЕНИЕ ВХОДНЫХ ДАННЫХ ---
    int n, m;                         // n - количество строк, m - количество столбцов
    cin >> n >> m;                    // Считываем размеры таблицы

    vector<string> table(n);          // Создаем вектор строк для хранения таблицы
    for (int i = 0; i < n; ++i) {
        cin >> table[i];              // Считываем каждую строку таблицы
    }

    // --- ПРЕДВАРИТЕЛЬНЫЙ РАСЧЕТ СУММ ---

    // 1. Расчет максимально возможных сумм для каждой СТРОКИ
    // Мы предполагаем, что для максимальной суммы каждый '?' равен '+' (то есть +1).
    vector<int> max_row_sums(n);      // Вектор для хранения максимальных сумм всех строк
    for (int i = 0; i < n; ++i) {
        int current_row_sum = 0;      // Сумма для текущей строки i
        for (char c : table[i]) {     // Проходим по каждому символу в строке
            if (c == '-') {
                current_row_sum -= 1; // '-' всегда -1
            } else {
                current_row_sum += 1; // '+' и '?' считаем как +1 для максимизации
            }
        }
        max_row_sums[i] = current_row_sum; // Сохраняем результат для строки i
    }

    // 2. Расчет минимально возможных сумм для каждого СТОЛБЦА
    // Мы предполагаем, что для минимальной суммы каждый '?' равен '-' (то есть -1).
    vector<int> min_col_sums(m);      // Вектор для хранения минимальных сумм всех столбцов
    for (int j = 0; j < m; ++j) {
        int current_col_sum = 0;      // Сумма для текущего столбца j
        for (int i = 0; i < n; ++i) { // Проходим по каждому элементу в столбце
            if (table[i][j] == '+') {
                current_col_sum += 1; // '+' всегда +1
            } else {
                current_col_sum -= 1; // '-' и '?' считаем как -1 для минимизации
            }
        }
        min_col_sums[j] = current_col_sum; // Сохраняем результат для столбца j
    }

    // --- ОСНОВНОЙ АЛГОРИТМ: ПОИСК МАКСИМАЛЬНОЙ РАЗНОСТИ ---

    // Инициализируем итоговую переменную очень маленьким числом
    long long max_overall_difference = LLONG_MIN; 
    
    // Перебираем все возможные пары (строка i, столбец j)
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            // Считаем "наивную" разность, используя предрассчитанные значения
            long long current_diff = (long long)max_row_sums[i] - min_col_sums[j];

            // Проверяем наличие конфликта в ячейке на пересечении (i, j)
            if (table[i][j] == '?') {
                // Если тут '?', то при расчете max_row_sums мы посчитали его как +1,
                // а при расчете min_col_sums - как -1.
                // Это создало невозможную ситуацию. Вклад в разность получился (+1) - (-1) = 2.
                // В реальности же, при любом выборе ('+' или '-'), вклад ячейки в разность будет 0.
                // Например, (+1) - (+1) = 0.
                // Поэтому мы должны скорректировать нашу "наивную" разность, вычтя 2.
                current_diff -= 2;
            }

            // Обновляем максимальную найденную разность
            if (current_diff > max_overall_difference) {
                max_overall_difference = current_diff;
            }
        }
    }

    // --- ВЫВОД РЕЗУЛЬТАТА ---
    cout << max_overall_difference << endl; // Печатаем итоговый ответ

    return 0; // Завершаем программу
}
```