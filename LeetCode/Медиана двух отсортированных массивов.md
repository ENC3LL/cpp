# Медиана двух отсортированных массивов

Даны два отсортированных массива `nums1` и `nums2` длины `m` и `n` соответственно. Верните **медиану** двух отсортированных массивов.

Общая сложность по времени должна быть `O(log (m+n))`.

**Пример 1:**

**Ввод:** nums1 = [1,3], nums2 = [2]
**Вывод:** 2.00000
**Пояснение:** объединенный массив = [1,2,3], медиана равна 2.**Пример 2:**

**Ввод:** nums1 = [1,2], nums2 = [3,4]
**Вывод:** 2.50000
**Пояснение:** объединенный массив = [1,2,3,4], медиана равна (2 + 3) / 2 = 2.5.

# Ответ

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    vector<int> result = nums1;
    result.insert(result.end(), nums2.begin(), nums2.end());
    
    // Сортируем объединенный массив (если исходные не отсортированы)
    sort(result.begin(), result.end());
    
    int n = result.size();
    double val;
    
    if (n % 2 == 0) {
        // Для четного: среднее двух центральных элементов
        int m = n / 2;
        val = (result[m - 1] + result[m]) / 2.0;  // 2.0 для double деления
    } else {
        // Для нечетного: центральный элемент
        int m = n / 2;
        val = result[m];
    }
    
    return val;
}
```

## Второй вариант (быстрее)

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size() + nums2.size();
    int i = 0, j = 0;
    int prev = 0, curr = 0;
    
    for (int count = 0; count <= n / 2; count++) {
        prev = curr;
        
        if (i < nums1.size() && (j >= nums2.size() || nums1[i] <= nums2[j])) {
            curr = nums1[i++];
        } else {
            curr = nums2[j++];
        }
    }
    
    if (n % 2 == 0) {
        return (prev + curr) / 2.0;
    } else {
        return curr;
    }
}
```

## Первый алгоритм (объединение + сортировка):
```cpp
vector<int> result = nums1;                    // O(n)
result.insert(result.end(), nums2.begin(), nums2.end()); // O(m)
sort(result.begin(), result.end());            // O((n+m) * log(n+m))
```
**Итоговая сложность: O((n+m) * log(n+m))**

## Второй алгоритм (слияние на лету):
```cpp
for (int count = 0; count <= n / 2; count++) { // O((n+m)/2) ≈ O(n+m)
    // только сравнения и присваивания
}
```
**Итоговая сложность: O(n+m)**

## Наглядное сравнение:

| Операция | Алгоритм 1 | Алгоритм 2 |
|----------|------------|------------|
| Память   | O(n+m)     | O(1)       |
| Время    | O(N log N) | O(N)       |
| Где N = n+m | ~ N log N операций | ~ N/2 операций |

## Почему такая разница?

**Первый алгоритм:**
- Создает полную копию обоих массивов
- Сортирует ВСЕ элементы (даже те, что не нужны для медианы)
- Тратит время на полную сортировку

**Второй алгоритм:**
- Работает "на лету" без создания полной копии
- Находит только СРЕДНИЕ элементы (остальные игнорирует)
- Использует факт, что массивы уже отсортированы

## Аналогия:
- **Алгоритм 1** - как перебирать всю библиотеку чтобы найти одну книгу
- **Алгоритм 2** - как сразу пойти к нужной полке и взять книгу

Для больших массивов (миллионы элементов) разница будет **огромной** - второй алгоритм может работать в **100+ раз быстрее**!