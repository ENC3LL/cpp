# Соответствие регулярному выражению

Дана строка `s` и шаблон `p`, реализуйте функцию для проверки на соответствие регулярному выражению, которая поддерживает `'.'` и `'*'`, где:

* `'.'` соответствует любому отдельному символу.
* `'*'` соответствует нулю или более элементам до `'*'`.

Нужно сопоставить **всю** строку, а не только ее части.

**Пример 1:**

**Ввод:** s = "aa", p = "a"
**Вывод:** false
**Пояснение:** "a" не сопоставим со строкой "aa".**Пример 2:**

**Ввод:** s = "aa", p = "a*"
**Вывод:** true
**Пояснение:** '*' означает ноль или более элементов до '*', до '*' стоит 'a'. Следовательно, мы можем повторить 'a'. Повторяем один раз и получаем соответствие - "aa".**Пример 3:**

**Ввод:** s = "ab", p = ".*"
**Вывод:** true
**Пояснение:** ".*" означает 'ноль или более (*) любых символов (.)'.

# Решение

Своё адекватное но не самое быстрое 299ms
назначить кажому чар условие (что-то типо char '*'=[a-z,A-Z] в TS и JS), а затем использовать это в проверке

```c++


class Solution {
public:
    bool isMatch(string s, string p) {
        // Преобразуем string в C-style строки и запускаем рекурсивную функцию
        return isMatchHelper(s.c_str(), p.c_str());
    }
    
private:
    bool isMatchHelper(const char* s, const char* p) {
        // Базовый случай: если паттерн закончился, строка тоже должна закончиться
        if (*p == '\0') return *s == '\0';
        
        // Обработка символа '*' в паттерне (следующий символ после текущего)
        if (*(p + 1) == '*') {
            // Два варианта при наличии '*':
            // 1. Пропустить символ с '*' в паттерне (0 повторений) - isMatchHelper(s, p + 2)
            // 2. Использовать символ с '*' (1+ повторений) если текущий символ строки совпадает с паттерном
            return isMatchHelper(s, p + 2) ||                    // Вариант 1: пропускаем символ и '*'
                   (*s != '\0' && (*s == *p || *p == '.') &&    // Проверяем что строка не пуста и символы совпадают
                    isMatchHelper(s + 1, p));                   // Вариант 2: используем символ, продвигаем строку
        }
        
        // Обработка обычного символа или '.' (без '*' после)
        if (*s != '\0' && (*p == '.' || *s == *p)) {
            // Если символы совпадают (или паттерн '.'), продвигаем обе строки
            return isMatchHelper(s + 1, p + 1);
        }
        
        // Если ни одно условие не выполнилось - нет совпадения
        return false;
    }
};


```



## Пояснение работы алгоритма:

### Примеры:* `isMatch("aa", "a*")` → `true`* `'a'` совпадает с `'a'`, `'*'` позволяет 0+ повторений
* `'a'` совпадает с `'a'`, `'*'` позволяет 0+ повторений
* `isMatch("ab", ".*")` → `true`* `'.'` любой символ, `'*'` любое количество
* `'.'` любой символ, `'*'` любое количество
* `isMatch("aab", "c*a*b")` → `true`* `'c'` может быть 0 раз из-за `'*'`
* `'c'` может быть 0 раз из-за `'*'`

### Ключевые моменты:* `*p` - текущий символ паттерна
* `*s` - текущий символ строки
* `'\0'` - конец строки
* Рекурсия обрабатывает все возможные варианты совпадения



# Самый быстрый 3ms



```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.length(), n = p.length();
        std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));

        dp[0][0] = true;

        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
                }
                else {
                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.');
                }
            }
        }
        return dp[m][n];
    }
};
```

