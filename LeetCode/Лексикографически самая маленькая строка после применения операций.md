# Лексикографически самая маленькая строка после применения операций

требуется написать алгоритм, который преобразует исходную строку `s` (чётной длины, состоящую из цифр 0-9) с помощью двух операций, чтобы получить лексикографически наименьшую строку.

**Операции:**

1. **Добавление `a` к нечётным индексам** (индексация с 0):

* К каждой цифре на нечётной позиции (1, 3, 5, ...) прибавляется значение `a`
* Если результат превышает 9, происходит циклический возврат к 0 (по модулю 10)
* *Пример:* `s = "3456"`, `a = 5` → `"3951"`

2. **Циклический сдвиг вправо на `b` позиций**:

* *Пример:* `s = "3456"`, `b = 1` → `"6345"`
* *Пример:* `s = "3456"`, `b = 1` → `"6345"`

**Цель:** Применяя эти операции любое количество раз в любом порядке, получить строку с наименьшим лексикографическим порядком.

**Лексикографический порядок:** Сравниваются строки посимвольно слева направо, и первое различие определяет, какая строка меньше.

**Пример из задачи:**

Ввод: s = "5525", a = 9, b = 2
Вывод: "2050"
Вам нужно реализовать функцию, которая принимает строку `s` и целые числа `a`, `b`, и возвращает лексикографически наименьшую строку, достижимую с помощью этих операций.

```c++
class Solution {
public:
    string findLexSmallestString(string s, int a, int b) {
        int n = s.size();
        string smallest = s;
        
        // Поскольку операции можно применять многократно, мы можем:
        // 1. Вращать строку много раз (цикл из n/gcd(n,b) различных состояний)
        // 2. Для каждого вращения применять операцию сложения к нечётным индексам
        
        // Находим все уникальные вращения
        int rotations = n / gcd(n, b);
        
        for (int i = 0; i < rotations; i++) {
            // Для текущего вращения пробуем разные количества операций сложения
            // Максимум 10 операций, т.к. после 10 цикл повторяется
            for (int add1 = 0; add1 < 10; add1++) {
                // Операция сложения применяется только к нечётным индексам
                string temp = s;
                
                // Применяем операцию сложения add1 раз к нечётным индексам
                for (int j = 1; j < n; j += 2) {
                    int digit = temp[j] - '0';
                    digit = (digit + add1 * a) % 10;
                    temp[j] = digit + '0';
                }
                
                // Если b нечётное, можем также менять чётные индексы
                // через дополнительное вращение + операцию сложения
                if (b % 2 == 1) {
                    for (int add2 = 0; add2 < 10; add2++) {
                        string temp2 = temp;
                        // Применяем к чётным индексам
                        for (int j = 0; j < n; j += 2) {
                            int digit = temp2[j] - '0';
                            digit = (digit + add2 * a) % 10;
                            temp2[j] = digit + '0';
                        }
                        smallest = min(smallest, temp2);
                    }
                } else {
                    smallest = min(smallest, temp);
                }
            }
            
            // Вращаем строку для следующей итерации
            s = s.substr(n - b) + s.substr(0, n - b);
        }
        
        return smallest;
    }
    
private:
    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
};
```

