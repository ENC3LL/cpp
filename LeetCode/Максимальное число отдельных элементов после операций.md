# Максимальное число отдельных элементов после операций

Вам даны целочисленный массив и целочисленный .`nums``k`
Вы можете выполнить следующую **операцию** над каждым элементом массива **не более** *одного раза*:

* Добавьте к элементу целое число в диапазоне.`[-k, k]`

Возвращает **максимально** возможное количество **отдельных** элементов после выполнения **операций**.`nums`

**Пример 1:**

**Входные данные:** nums = [1,2,2,3,3,4], k = 2

**Выход:** 6

**Объяснение:**

`nums` Изменяется на после выполнения операций над первыми четырьмя элементами.`[-1, 0, 1, 2, 3, 4]`

**Пример 2:**

**Входные данные:** nums = [4,4,4,4], k = 1

**Выход:** 3

**Объяснение:**

При добавлении -1 к и 1 к , изменения в .`nums[0]``nums[1]``nums``[3, 5, 4, 4]`



# Решение

```c++
class Solution {
public:
    int maxDistinctElements(vector<int>& nums, int k) {
        if (nums.empty()) return 0;
        sort(nums.begin(), nums.end());

        long long current = (long long)nums[0] - k;
        int count = 1;

        for (int i = 1; i < nums.size(); i++) {
            long long min_val = (long long)nums[i] - k;
            long long max_val = (long long)nums[i] + k;

            if (min_val > current) {
                current = min_val;
                count++;
            }
            else if (current + 1 <= max_val) {
                current = current + 1;
                count++;
            }
        }
        return count;
    }
};
```

# Пояснение

Что это за задача? (Аналогия с расстановкой флагов)

Представь, что у тебя есть длинная линейка (числовая ось) и несколько колышков. Каждый колышек воткнут в определенную точку на линейке — это числа из нашего массива `nums`.

Правила игры такие:

* Ты можешь взять любой колышек и сдвинуть его влево или вправо на расстояние **не больше, чем `k`**.
* Твоя цель — после всех передвижений расставить колышки так, чтобы как можно больше из них стояли на **уникальных целых отметках** на линейке.

Например, если два колышка стоят в точке `3`, и `k=1`, ты можешь оставить один на месте, а второй сдвинуть в `2` или `4`, чтобы они заняли разные отметки. Задача — найти максимальное количество уникальных позиций, которые можно занять.

**Главная идея решения** — быть "жадным" (использовать **жадный алгоритм**). Чтобы оставить как можно больше места для следующих колышков, каждый текущий колышек мы будем стараться сдвинуть **как можно левее** (присвоить ему наименьшее возможное уникальное значение).

---

## Часть 1: Подготовка сцены — Сортировка и инициализация

Прежде чем расставлять флаги, давайте наведём порядок.

### Код

```cpp
class Solution {
public:
    int maxDistinctElements(vector<int>& nums, int k) {
        // Проверка на пустой массив
        if (nums.empty()) return 0;
        
        // Сортируем массив по возрастанию
        sort(nums.begin(), nums.end());

        // 'current' будет хранить последнее занятое нами уникальное значение
        // Начинаем с самого минимального возможного значения для первого элемента
        long long current = (long long)nums[0] - k;
        // Мы уже "поставили" один флаг, так что счетчик уникальных = 1
        int count = 1;
        
        // ... остальной код
```

### Пояснение

1. **`if (nums.empty()) return 0;`**
   - **Что делает:** Простая проверка. Если массив пустой, то и уникальных элементов в нём 0.
   - **Принцип:** Защита от ошибок и обработка крайнего случая.

2. **`sort(nums.begin(), nums.end());`**
   - **Что делает:** Сортирует все числа в массиве `nums` от меньшего к большему.
   - **Принцип (Зачем это нужно?):** Сортировка — **ключевой шаг**. Она позволяет нам рассматривать числа последовательно. Обработав число `5`, мы знаем, что следующее число будет `5` или больше. Это избавляет от хаоса и позволяет применять простую жадную стратегию. Без сортировки нам пришлось бы перебирать сложнейшие комбинации.

3. **`long long current = (long long)nums[0] - k;`**
   - **Что делает:** Мы берём самое первое (теперь уже самое маленькое) число `nums[0]`. Мы можем превратить его в любое значение в диапазоне `[nums[0] - k, nums[0] + k]`. Наша жадная стратегия гласит: "займи как можно меньшее значение, чтобы оставить больше места для других". Поэтому мы выбираем `nums[0] - k` — самое левое положение для нашего первого "флага". Это значение мы сохраняем в переменной `current`.
   - **Принцип:** `long long` используется для подстраховки. Числа в `nums` и `k` могут быть большими (до $10^9$), и их сумма или разность может выйти за пределы обычного `int`. `long long` имеет гораздо больший диапазон и предотвращает ошибки переполнения.

4. **`int count = 1;`**
   - **Что делает:** Запускает наш счётчик. Мы уже приняли решение для первого элемента и успешно заняли одну уникальную позицию, поэтому `count` сразу равен 1.

---

## Часть 2: Главный цикл — Жадная расстановка остальных флагов

Теперь мы идём по остальным колышкам и решаем, куда их передвинуть.

### Код

```cpp
// ... внутри функции
        // Начинаем со второго элемента (индекс 1), так как первый уже обработали
        for (int i = 1; i < nums.size(); i++) {
            // Для текущего числа nums[i] вычисляем его возможный диапазон
            long long min_val = (long long)nums[i] - k; // Самая левая позиция
            long long max_val = (long long)nums[i] + k; // Самая правая позиция

            // ... логика внутри цикла
        }
// ...
```

### Пояснение

Мы запускаем цикл от второго элемента (`i = 1`) до конца массива. Для каждого числа `nums[i]` мы сначала определяем его "зону свободы" — диапазон `[min_val, max_val]`, в который мы можем его переместить.

---

## Часть 3: Логика принятия решений внутри цикла

Это сердце алгоритма. Для каждого числа мы проверяем два возможных сценария.

### Код

```cpp
// ... внутри цикла for
            // Сценарий 1: "Идеальный случай"
            // Если самая левая позиция для текущего числа (min_val)
            // уже больше, чем последняя занятая нами позиция (current)...
            if (min_val > current) {
                // ...то мы можем смело занять эту самую левую позицию.
                current = min_val;
                count++; // Ура, мы нашли еще одно уникальное место!
            } 
            // Сценарий 2: "Нужно немного подумать"
            // Если предыдущий if не сработал, значит min_val <= current.
            // Но может быть, мы можем занять позицию `current + 1`?
            else if (current + 1 <= max_val) {
                // Если `current + 1` находится в пределах нашей "зоны свободы"...
                // ...то мы занимаем это место. Это наименьшее доступное уникальное место.
                current = current + 1;
                count++; // Еще одно уникальное место найдено!
            }
            // Неявный "else": Если оба if не сработали, значит вся "зона свободы"
            // для текущего числа уже занята. Мы не можем получить из него
            // новый уникальный элемент. Просто переходим к следующему числу.
```

### Пояснение

Давай разберём на примере. Пусть `current = 10`. Это значит, что последнее уникальное число, которое мы "заняли", это 10. Теперь мы рассматриваем новое число `nums[i]`, у которого `k=2`.

#### Сценарий 1: `if (min_val > current)`

* Допустим, `nums[i] = 13`. Тогда его `min_val` будет `13 - 2 = 11`.
* Условие `11 > 10` истинно. Это значит, что даже самое маленькое значение, в которое мы можем превратить `nums[i]`, уже уникально и не конфликтует с `current`.
* **Наше жадное решение:** Мы выбираем `11`. `current` становится равен `11`, а `count` увеличивается. Мы снова заняли самую левую из доступных позиций, чтобы оставить максимум места для будущих чисел.

#### Сценарий 2: `else if (current + 1 <= max_val)`

* Допустим, `nums[i] = 11`. Его диапазон `[11 - 2, 11 + 2]`, то есть `[9, 13]`.
* `min_val` равен `9`. Условие `9 > 10` ложно. Мы не можем просто взять `min_val`.
* Тогда мы проверяем: а можем ли мы занять следующую свободную ячейку, то есть `current + 1` (в нашем случае, `11`)?
* Условие `11 <= max_val` (т.е., `11 <= 13`) истинно. Да, мы можем превратить `nums[i]` в `11`!
* **Наше жадное решение:** Мы занимаем позицию `11`. `current` становится равен `11`, `count` увеличивается. Мы снова выбрали самое маленькое из возможных *уникальных* значений.

#### Сценарий 3 (Неявный `else`):

* Допустим, `nums[i] = 8`, `k=1`. Его диапазон `[7, 9]`. `current` всё ещё `10`.
* `min_val = 7`. Условие `7 > 10` ложно.
* `max_val = 9`. Условие `current + 1 <= max_val` (т.е. `11 <= 9`) тоже ложно.
* Это означает, что весь диапазон `[7, 9]`, в который мы можем превратить `nums[i]`, уже меньше или равен последней занятой нами позиции `10`. Мы никак не можем получить из этого числа новое уникальное значение, которое было бы больше `10`.
* **Решение:** Мы ничего не делаем. `count` не увеличивается, `current` не меняется. Мы просто теряем возможность использовать это число для увеличения количества уникальных элементов.

---

## Часть 4: Финальный результат

После того как цикл прошёл по всем элементам, мы просто возвращаем накопленное значение.

### Код

```cpp
// ... после цикла
        return count;
    }
};
```

### Пояснение

Переменная `count` на каждом шаге цикла честно считала, сколько раз нам удалось успешно "поставить флаг" на новую уникальную отметку на нашей линейке. Поэтому в конце она содержит итоговый максимальный результат.

---

## Почему этот алгоритм работает?

### Жадная стратегия оправдана:

1. **Сортировка обеспечивает порядок:** Обрабатывая числа от меньшего к большему, мы гарантируем, что если текущее число не может занять позицию, то все последующие числа (которые больше или равны) тоже не смогут занять более левые позиции.

2. **Минимизация занимаемого места:** Всегда выбирая наименьшее возможное уникальное значение, мы оставляем максимальное пространство для последующих чисел.

3. **Эффективность:** Алгоритм работает за O(n log n) из-за сортировки и O(n) для одного прохода по массиву, что оптимально для типичных ограничений.

### Пример работы:

```
nums = [3, 3, 3], k = 2
После сортировки: [3, 3, 3]

1-й элемент: current = 3-2 = 1, count = 1
2-й элемент: min_val = 1, max_val = 5
   min_val (1) <= current (1) → проверяем current+1 = 2 ≤ 5 → да
   current = 2, count = 2
3-й элемент: min_val = 1, max_val = 5  
   min_val (1) <= current (2) → проверяем current+1 = 3 ≤ 5 → да
   current = 3, count = 3

Результат: 3 уникальных элемента
```

Алгоритм успешно находит максимальное количество уникальных элементов, которое можно получить при заданных ограничениях!