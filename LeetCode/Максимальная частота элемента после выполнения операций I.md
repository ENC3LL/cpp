# Максимальная частота элемента после выполнения операций I

Вам дан целочисленный массив и два целых числа, а также .`nums``k``numOperations`

Вы должны выполнить **операцию** времени на , где в каждой операции вы:`numOperations``nums`

* Выберите индекс, который **не** был выбран ни в одной из предыдущих операций.`i`
* Сложите целое число в диапазоне до .`[-k, k]``nums[i]`

Вернуть **максимально** возможное частота любого элемента после выполнения **операций**.`nums`

 

**Пример 1:**

**Входные данные:** nums = [1,4,5], k = 1, numOperations = 2

**Выход:** 2

**Объяснение:**

Мы можем достичь максимальной частоты двух путем:

* Добавление 0 к . Становится.`nums[1]``nums``[1, 4, 5]`
* Прибавляем -1 к . Становится.`nums[2]``nums``[1, 4, 4]`

**Пример 2:**

**Входные данные:** nums = [5,11,20,20], k = 5, numOperations = 1

**Выход:** 2

**Объяснение:**

Мы можем достичь максимальной частоты двух путем:

* Добавление 0 к .`nums[1]`


# Решение

```c++
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int maxVal = *max_element(nums.begin(), nums.end()) + k + 2;
        int* count = new int[maxVal]();

        for (int v : nums)
            count[v]++;

        for (int i = 1; i < maxVal; i++)
            count[i] += count[i - 1];

        int res = 0;
        for (int i = 0; i < maxVal; i++) {
            int left = max(0, i - k);
            int right = min(maxVal - 1, i + k);
            int total = count[right] - (left ? count[left - 1] : 0);
            int freq = count[i] - (i ? count[i - 1] : 0);
            res = max(res, freq + min(numOperations, total - freq));
        }

        return res;
    }
};

```



## Подход

Мы хотим максимально увеличить частоту целевого значения тарге т, для этого мы можем преобразовывать элементы в диапазоне [таргет− к,т а р г е т+k] чтобы стать тарге т путем добавления соответствующих значений.

Например, если тарге т=5 и k=2:

* Элемент 3 может стать 5 добавив +2
* Элемент 7 может стать 5 добавив −2
* Элемент 4 может стать 5 добавив +1

Вместо того, чтобы пробовать все возможные преобразования, мы используем метод фрекуенсикоу нтин г  Подход в сочетании с суммами префиксов позволяет эффективно вычислить, сколько элементов может быть преобразовано в каждое возможное целевое значение.

* Во-первых, мы отслеживаем, сколько раз каждое значение появляется в исходном массиве
* Далее создайте массив сумм префиксов для запросов по диапазону
* Затем для каждого потенциального целевого значения рассчитайте, сколько элементов можно преобразовать в него
* Ответ — максимально достижимая частота по всем целям

Для целевого значения я, мы можем рассчитать:

total=count[i+k]−count[i−k−1]​Это дает нам общее количество элементов, которые могут быть преобразованы в я.

Максимальная частота для цели я есть:

res=freq+min(numOp s,t otal−fre q)​Где:

* freq = элементы, уже равные я
* тоталfreq = элементы в диапазоне, которые могут стать я (за исключением уже равных)

Попробуйте все возможные целевые значения:

* Для каждой потенциальной цели я От 0 Кому maxVal−1:

## Алгоритм
Определите границы диапазона:

лефтригчт​=max(0,i−k)=min(maxVal−1,i+k)​Вычисление итоговых элементов в диапазоне:

total=count[right]−count[left−1]​Это дает нам все элементы в:

[i−k,i+k]​Рассчитайте исходную частоту:

fre q=count[i]−count[i−1]​Это дает нам элементы, уже равные я.

Максимальная частота обновления данных:

res=max(res,f req+min(numOp s,t otal−fre q))​Наконец, верните максимальную частоту для всех целевых значений.

**Временная сложность**: O(n+m)
**Сложность пространства**: О(м)



