# Максимальная частота элемента после выполнения операций II

Вам дан целочисленный массив и два целых числа, а также .`nums``k``numOperations`

Вы должны выполнить **операцию** времени на , где в каждой операции вы:`numOperations``nums`

* Выберите индекс, который **не** был выбран ни в одной из предыдущих операций.`i`
* Сложите целое число в диапазоне до .`[-k, k]``nums[i]`

Вернуть **максимально** возможное частота любого элемента после выполнения **операций**.`nums`

 

**Пример 1:**

**Входные данные:** nums = [1,4,5], k = 1, numOperations = 2

**Выход:** 2

**Объяснение:**

Мы можем достичь максимальной частоты двух путем:

* Прибавляя 0 к , после чего получается .`nums[1]``nums``[1, 4, 5]`
* Прибавляем -1 к , после чего получается .`nums[2]``nums``[1, 4, 4]`

**Пример 2:**

**Входные данные:** nums = [5,11,20,20], k = 5, numOperations = 1

**Выход:** 2

**Объяснение:**

Мы можем достичь максимальной частоты двух путем:

* Добавление 0 к .`nums[1]`


# Решение

```c++
class Solution {
public:
    int check(vector<int>& nums, int n, int t, int m) {
        long long nL = n;
        long long tL = t;
        int l = lower_bound(nums.begin(), nums.end(), nL) - nums.begin();
        int h = upper_bound(nums.begin(), nums.end(), nL) - nums.begin();
        int ll = lower_bound(nums.begin(), nums.end(), nL - tL) - nums.begin();
        int hh = upper_bound(nums.begin(), nums.end(), nL + tL) - nums.begin();
        int res = (hh - h) + (l - ll);
        return min(m, res) + (h - l);
    }

    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int m = numOperations;
        sort(nums.begin(), nums.end());
        int ans = 1;
        for (int i = 0; i < nums.size() - 1; i++) {
            ans = max(check(nums, nums[i], k, m), ans);
            ans = max(check(nums, nums[i] - k, k, m), ans);
            ans = max(check(nums, nums[i] + k, k, m), ans);
        }
        return ans;
    }
};
```


# Интуиция
Цель состоит в том, чтобы максимизировать частоту любого числа в массиве после выполнения не более , где в каждой операции мы можем добавить или вычесть любое значение между и к отдельному элементу.
По сути, мы хотим сделать как можно больше чисел равными (или в диапазоне, который можно сделать равным с помощью разрешенных модификаций).`numOperations``-k``k`

# Подход1. 
**Сортировка**:
Во-первых, отсортируйте массив для эффективного поиска чисел в заданном диапазоне с помощью двоичного поиска.`nums`
2. **Проверка частоты вокруг каждого числа**:
для каждого числа в отсортированном массиве мы находим, сколько элементов можно преобразовать с использованием в большинстве операций, при этом каждая операция изменяет значение в пределах диапазона .`n``n``numOperations``[-k, k]`
3. **Бинарный поиск диапазона**:

* Используя и , мы находим индексы чисел в пределах .`lower_bound``upper_bound``[n - k, n + k]`
* Количество элементов, на которые можно изменить, зависит от того, сколько из них уже равно , и сколько близлежащих значений попадает в допустимый диапазон (ограниченный оставшимися операциями).`n``n`
4. Используя и , мы находим индексы чисел в пределах .`lower_bound``upper_bound``[n - k, n + k]`
5. Количество элементов, на которые можно изменить, зависит от того, сколько из них уже равно , и сколько близлежащих значений попадает в допустимый диапазон (ограниченный оставшимися операциями).`n``n`
6. **Максимизируйте ответ**:
Мы проверяем эту логику для трех наблюдений для каждого числа:

* Использование себя в качестве целевого значения.`n`
* Использование в качестве потенциальной нижней мишени.`n - k`
* Использование в качестве потенциальной более высокой цели.`n + k`

В результате получается максимально достижимая частота.
7. Использование себя в качестве целевого значения.`n`
8. Использование в качестве потенциальной нижней мишени.`n - k`
9. Использование в качестве потенциальной более высокой цели.`n + k`

# Сложность
**Временная сложность:**
Сортировка занимает (O(n \log n)), а для каждого элемента выполняются операции двоичного поиска (O(\log n)).
Итого: **(O(n \log n))**
* **Сложность пространства:**
Используется только несколько дополнительных переменных, поэтому **(O(1))** дополнительное пространство.



