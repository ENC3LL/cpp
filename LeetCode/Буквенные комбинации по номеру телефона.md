# Буквенные комбинации по номеру телефона
Дана строка `digits`, содержащая цифры от `2` до `9` включительно, верните все возможные буквенные комбинации, которые может образовать данная строка. Верните ответ в **любом порядке**.

Соответствие цифр буквам (как на кнопках телефона) приведено ниже. Обратите внимание, что 1 не соответствует ни одной букве.

![image](./.assets/image-1761344057652.png)

**Пример 1:**

**Ввод:** digits = "23"
**Вывод:** ["ad","ae","af","bd","be","bf","cd","ce","cf"]**Пример 2:**

**Ввод:** digits = ""
**Вывод:** []**Пример 3:**

**Ввод:** digits = "2"
**Вывод:** ["a","b","c"]

# Решение

```c++
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        // Если входная строка пустая, сразу возвращаем пустой вектор
        if (digits.empty()) return {};
        
        // Создаем массив, имитирующий телефонную клавиатуру
        // Индексы 0-9, где каждому индексу соответствуют буквы на кнопке
        vector<string> keypad = {
            "", "", "abc", "def", "ghi", "jkl", "mno", 
            "pqrs", "tuv", "wxyz"  // 7 и 9 имеют по 4 буквы
        };
        
        // Инициализируем результат с пустой строкой - база для построения комбинаций
        vector<string> result = {""};
        
        // Обрабатываем каждую цифру во входной строке
        for (char digit : digits) {
            vector<string> temp;  // Временный вектор для хранения новых комбинаций
            
            // Получаем строку с буквами для текущей цифры
            // digit - '0' преобразует символ цифры в число (например, '2' -> 2)
            string letters = keypad[digit - '0'];
            
            // Для каждой уже существующей комбинации в result...
            for (string s : result) {
                // ...и для каждой буквы, соответствующей текущей цифре...
                for (char letter : letters) {
                    // ...создаем новую комбинацию и добавляем во временный вектор
                    temp.push_back(s + letter);
                }
            }
            
            // Заменяем старый результат новыми комбинациями
            // Это похоже на "переход на следующий уровень" в BFS
            result = temp;
        }
        
        return result;
    }
};
```


### 1. **Инициализация*** 
Если входная строка `digits` пуста, сразу возвращается пустой список `[]`.
* Создается массив `keypad`, где индекс соответствует цифре, а значение — строка с буквами (например, `keypad[2] = "abc"`).

### 2. **Базовый случай*** 
Вектор `result` инициализируется с одним элементом — пустой строкой `""`. Это нужно для последующего наращивания комбинаций.

### 3. **Генерация комбинаций**

Для каждой цифры в `digits`:

* **Получаем буквы** из `keypad`, соответствующие текущей цифре (например, для `'2'` это `"abc"`).
* **Создаем временный вектор `temp`**, который будет хранить новые комбинации.
* **Для каждой существующей комбинации** в `result` и **каждой буквы** из `letters`:

* Формируем новую строку `s + letter` и добавляем ее в `temp`.
* Формируем новую строку `s + letter` и добавляем ее в `temp`.
* **Заменяем `result` на `temp`**, переходя к следующему уровню комбинаций.

### 4. **Пример для `digits = "23"`*** **Шаг 1:** Обрабатываем `'2'` (буквы `"abc"`).

* `result = ["a", "b", "c"]`.
* `result = ["a", "b", "c"]`.
* **Шаг 2:** Обрабатываем `'3'` (буквы `"def"`).

* Комбинируем каждую строку из `result` с каждой буквой `"def"`:

* `"a" + "d"`, `"a" + "e"`, ... → `["ad", "ae", "af", "bd", ...]`.
* `"a" + "d"`, `"a" + "e"`, ... → `["ad", "ae", "af", "bd", ...]`.
* Комбинируем каждую строку из `result` с каждой буквой `"def"`:

* `"a" + "d"`, `"a" + "e"`, ... → `["ad", "ae", "af", "bd", ...]`.
* `"a" + "d"`, `"a" + "e"`, ... → `["ad", "ae", "af", "bd", ...]`.




