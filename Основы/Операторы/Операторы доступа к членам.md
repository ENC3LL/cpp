# Операторы доступа к членам

Операторы доступа к членам: `.` и `->`


## Синтаксис *`postfix-expression`*:
  *`postfix-expression`* **`.`** **`template`** необ.*`id-expression`*
  *`postfix-expression`* **`->`** **`template`** необ.*`id-expression`*

## Замечания

Операторы **`.`** доступа к членам и **`->`** используются для ссылки на элементы `struct`и `union``class` типы. Выражения доступа к членам имеют значение и тип выбранного члена.

Предусмотрено две формы выражения доступа к члену:

1. В первой форме *`postfix-expression`* представляет значение `struct`или `class``union`тип, а также *`id-expression`* имя члена указанного `struct`элемента `union`или`class`. Значение операции — это *`id-expression`* значение l-value, если *`postfix-expression`* это l-значение.

2. Во второй форме *`postfix-expression`* представляет указатель на `struct`объект , `union`или `class`имя *`id-expression`* члена указанного `struct`элемента , `union`или `class`. Значением является `id-expression` значение l-value. Оператор **`->`** разыменовывает указатель. Выражения и (где `e->member` представляет указатель) дают идентичные результаты (за исключением случаев, когда операторы `(*(e)).member`*`e`* или **`->`** перегружены).**`*`**

## Пример

В следующем примере показаны обе формы оператора доступа к членам.

```cpp
// expre_Selection_Operator.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;

struct Date {
   Date(int i, int j, int k) : day(i), month(j), year(k){}
   int month;
   int day;
   int year;
};

int main() {
   Date mydate(1,1,1900);
   mydate.month = 2;
   cout  << mydate.month << "/" << mydate.day
         << "/" << mydate.year << endl;

   Date *mydate2 = new Date(1,1,2000);
   mydate2->month = 2;
   cout  << mydate2->month << "/" << mydate2->day
         << "/" << mydate2->year << endl;
   delete mydate2;
}
```
```output
2/1/1900
2/1/2000
```

