# Разрешение области

Оператор **`::`** разрешения области используется для идентификации и диамбигуации идентификаторов, используемых в разных областях. Дополнительные сведения о области см. в разделе 

## Синтаксис
*`qualified-id`*:
  *`nested-name-specifier`* **`template`** выбирать*`unqualified-id`*

 *`nested-name-specifier`*:
 **`::`**
  *`type-name`* **`::`**
   *`namespace-name`* **`::`**
   *`decltype-specifier`* **`::`**
  *`nested-name-specifier`* *`identifier`* **`::`**
  *`nested-name-specifier`* **`template`** выбирать*`simple-template-id`***`::`**

 *`unqualified-id`*:
 *`identifier`*
 *`operator-function-id`*
  *`conversion-function-id`*
 *`literal-operator-id`*
   **`~`** *`type-name`*
   **`~`** *`decltype-specifier`*
 *`template-id`*

## Замечания

Это `identifier` может быть переменная, функция или значение перечисления.

## Использование `::` для классов и пространств имен

В следующем примере показано, как оператор разрешения области используется с пространствами имен и классами:

C++
```cpp
namespace NamespaceA{
    int x;
    class ClassA {
    public:
        int x;
    };
}

int main() {

    // A namespace name used to disambiguate
    NamespaceA::x = 1;

    // A class name used to disambiguate
    NamespaceA::ClassA a1;
    a1.x = 2;
}

```

Оператор разрешения области без квалификатора области ссылается на глобальное пространство имен.

C++
```cpp
namespace NamespaceA{
    int x;
}

int x;

int main() {
    int x;

    // the x in main()
    x = 0;
    // The x in the global namespace
    ::x = 1;

    // The x in the A namespace
    NamespaceA::x = 2;
}

```

Оператор разрешения области можно использовать для идентификации члена элемента **`namespace`** или определения пространства имен, номинированного пространства имен члена в директиве **`using`** . В приведенном ниже примере можно использовать `NamespaceC` для квалификации `ClassB`, даже если `ClassB` она была объявлена в пространстве `NamespaceB`имен, так как `NamespaceB` она была назначена директивой `NamespaceC` **`using`** .

C++
```cpp
namespace NamespaceB {
    class ClassB {
    public:
        int x;
    };
}

namespace NamespaceC{
    using namespace NamespaceB;
}

int main() {
    NamespaceB::ClassB b_b;
    NamespaceC::ClassB c_b;

    b_b.x = 3;
    c_b.x = 4;
}

```

Можно использовать цепочки операторов разрешения области. В следующем примере `NamespaceD::NamespaceD1` определяет вложенное пространство `NamespaceD1`имен и `NamespaceE::ClassE::ClassE1` определяет вложенный класс `ClassE1`.

C++
```cpp
namespace NamespaceD{
    namespace NamespaceD1{
        int x;
    }
}

namespace NamespaceE{
    class ClassE{
    public:
        class ClassE1{
        public:
            int x;
        };
    };
}

int main() {
    NamespaceD:: NamespaceD1::x = 6;
    NamespaceE::ClassE::ClassE1 e1;
    e1.x = 7  ;
}

```

## Использование `::` статических элементов

Для вызова статических элементов классов необходимо использовать оператор разрешения области.

C++
```cpp
class ClassG {
public:
    static int get_x() { return x;}
    static int x;
};

int ClassG::x = 6;

int main() {

    int gx1 = ClassG::x;
    int gx2 = ClassG::get_x();
}

```

## Использование `::` для перечислений с областью действия

Оператор разрешения с областью действия также используется со значениями объявлений перечисления с областью действия, как показано в следующем примере:

C++
```cpp
enum class EnumA{
    First,
    Second,
    Third
};

int main() {
    EnumA enum_value = EnumA::First;
}
```



