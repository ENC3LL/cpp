# Оператор подстрока

Оператор подстрока: `[]`

## Синтаксис
```
postfix-expression
```

## Замечания
Выражение постфикса (которое также может быть первичным выражением), за которым следует оператор подстрочного индекса, **`[ ]`** указывает индексирование массива.

Сведения об управляемых массивах в C++/CLI

Как правило, значение, представленное *постфиксом- выражением* , является значением указателя, таким как идентификатор массива, и *выражение* является целочисленным значением (включая перечисленные типы). Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом целочисленное значение может находиться в *позиции postfix-expression* , а значение указателя может находиться в скобках в *позиции выражения* или подстроки. Рассмотрим следующий фрагмент кода:

```cpp
int nArray[5] = { 0, 1, 2, 3, 4 };
cout << nArray[2] << endl;            // prints "2"
cout << 2[nArray] << endl;            // prints "2"
```



В предыдущем примере выражение `nArray[2]` совпадает с `2[nArray]`. Причина заключается в том, что результат выражения `e1[e2]` подстрока дан следующим образом:

`*((e2) + (e1))`

Адрес, полученный выражением, не *является e2* байтами из адреса *e1*. Вместо этого адрес масштабируется, чтобы получить следующий объект в массиве *e2*. Например:

```cpp
double aDbl[2];
```

Адреса `aDb[0]` и `aDb[1]` равны 8 байтам друг от друга — размер объекта типа **`double`**. Это масштабирование в соответствии с типом объекта выполняется автоматически языком C++ и определяется в операторах аддитивных операторов, где обсуждаются добавление и вычитание операндов типа указателя.

Индексное выражение также может иметь несколько индексов, как показано ниже:

*expression1[expression2] [expression3]*

Индексные выражения связываются в направлении слева направо. Сначала вычисляется левое индексное выражение *expression1* **[expression2  ]**. Адрес, получающийся в результате сложения *expression1* и *expression2*, формирует выражение указателя. Затем к этому выражению указателя добавляется выражение *expression3*, чтобы образовать новое выражение указателя. Эти операции повторяются до тех пор, пока не будет добавлено последнее индексное выражение. Оператор косвенного обращения (**`*`**) применяется после вычисления последнего подстрочного выражения, если окончательное значение указателя не обращается к типу массива.

Выражения с несколькими индексами ссылаются на элементы многомерных массивов. Многомерный массив — это массив, элементы которого сами являются массивами. Например, первый элемент трехмерного массива является двумерным массивом. В следующем примере объявляется и инициализируется простой двухмерный массив символов.

```cpp
// expre_Subscript_Operator.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
#define MAX_ROWS 2
#define MAX_COLS 2

int main() {
  char c[ MAX_ROWS ][ MAX_COLS ] = { { 'a', 'b' }, { 'c', 'd' } };
  for ( int i = 0; i < MAX_ROWS; i++ )
     for ( int j = 0; j < MAX_COLS; j++ )
        cout << c[ i ][ j ] << endl;
}
```



## Положительные и отрицательные индексы

Первым элементом массива является элемент с номером 0. Диапазон массива C++ — от *массива[0] до *массива** [*размер* — 1]. Однако C++ поддерживает положительные и отрицательные индексы. Отрицательные индексы не должны выходить за границы массива; в противном случае результаты непредсказуемы. В следующем примере кода показаны положительные и отрицательные индексы массива:

```cpp
#include <iostream>
using namespace std;

int main() {
    int intArray[1024];
    for (int i = 0, j = 0; i < 1024; i++)
    {
        intArray[i] = j++;
    }

    cout << intArray[512] << endl;   // 512

    cout << 257[intArray] << endl;   // 257

    int *midArray = &intArray[512];  // pointer to the middle of the array

    cout << midArray[-256] << endl;  // 256

    cout << intArray[-256] << endl;  // unpredictable, may crash
}
```

Отрицательный подстрок в последней строке может привести к ошибке во время выполнения, так как он указывает на адрес 256 **`int`** позиций ниже в памяти, чем источник массива. Указатель `midArray` инициализируется в середине `intArray`; поэтому можно (но опасно) использовать на нем как положительные, так и отрицательные индексы массива. Ошибки индексов массивов не создают ошибки времени компиляции, но дают непредсказуемые результаты.

Оператор индекса коммутативен. Поэтому массив выражений[index] и *index*[*array*] гарантированно эквивалентен, если оператор подстрока не перегружен (см*. перегруженные операторы*).** Программисты чаще всего используют первую форму, но вторая форма также правильна.







