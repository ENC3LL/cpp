# Подсчёт островов в матрице (поиск в глубину - DFS)

Классическая задача на графы, где матрица выступает в роли сетки. "Остров" — это группа смежных (по вертикали/горизонтали) единиц. Мы перебираем каждую ячейку. Если находим '1' (часть суши), мы запускаем от неё "затопление" (DFS), которое помечает все ячейки этого острова как посещённые, и увеличиваем счётчик островов.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Функция "затопления" (DFS), которая обходит все части одного острова
void dfs_flood(int r, int c, vector<vector<char>>& grid) {
    int rows = grid.size();
    int cols = grid[0].size();

    // Базовые случаи для остановки рекурсии:
    // 1. Вышли за пределы матрицы
    // 2. Попали в воду '0' или уже посещенную ячейку '#'
    if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] != '1') {
        return;
    }

    // Помечаем текущую ячейку как посещенную
    grid[r][c] = '#'; 

    // Рекурсивно запускаемся для всех 4 соседей
    dfs_flood(r + 1, c, grid); // Вниз
    dfs_flood(r - 1, c, grid); // Вверх
    dfs_flood(r, c + 1, grid); // Вправо
    dfs_flood(r, c - 1, grid); // Влево
}

int main() {
    int rows, cols;
    cout << "Введите размеры карты (строки столбцы): ";
    cin >> rows >> cols;

    vector<vector<char>> grid(rows, vector<char>(cols));
    cout << "Введите карту ('1' - суша, '0' - вода):" << endl;
    for (int i = 0; i < rows; ++i) for (int j = 0; j < cols; ++j) cin >> grid[i][j];

    int island_count = 0;
    // Перебираем каждую ячейку карты
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            // Если находим непосещенную часть суши
            if (grid[i][j] == '1') {
                island_count++; // Это новый остров
                dfs_flood(i, j, grid); // "Затопляем" его, чтобы не посчитать снова
            }
        }
    }

    cout << "\nНайдено островов: " << island_count << endl;

    return 0;
}
```