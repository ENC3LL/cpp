# Подмассив с максимальной суммой

Дан массив целочисленных значений `nums`, найдите подмассив с наибольшей суммой и верните ее.

**Пример 1:**

**Ввод:** nums = [-2,1,-3,4,-1,2,1,-5,4]
**Вывод:** 6
**Пояснение:** Подмассив [4,-1,2,1] имеет наибольшую сумму, равную 6.**Пример 2:**

**Ввод:** nums = [1]
**Вывод:** 1
**Пояснение:** Подмассив [1] имеет наибольшую сумму, равную 1.**Пример 3:**

**Ввод:** nums = [5,4,-1,7,8]
**Вывод:** 23
**Пояснение:** Подмассив [5,4,-1,7,8] имеет наибольшую сумму, равную 23.

# Решение



### Поиск подмассива с максимальной суммой (Алгоритм Кадане)

Это твой вопрос: "поиск самого большого непрерывного куска с максимальным значением" (обычно имеется в виду *сумма*).

**Идея:** Мы идем по массиву и накапливаем "текущую сумму" (`current_sum`).

1. `max_sum` — хранит лучший результат, который мы *уже* видели.
2. `current_sum` — хранит сумму подмассива, который *заканчивается* на текущем элементе.
3. На каждом шаге мы решаем: нам выгоднее *продолжить* старый подмассив (добавив `vec[i]`) или *начать новый* (просто взяв `vec[i]`)? Это `current_sum = max(vec[i], current_sum + vec[i])`.
4. Если `current_sum` стал больше `max_sum`, обновляем `max_sum`.

```C++
#include <iostream>
#include <vector>
#include <algorithm> // Для max
#include <numeric>   // Для numeric_limits

using namespace std;

int main() {
    //                                     Вот этот кусок: {4, -1, 2, 1} = 6
    vector<int> v = {-2, 1, -3, 4, -1, 2, 1, -5, 4};

    if (v.empty()) {
        cout << "Массив пуст!" << endl;
        return 0;
    }

    int max_sum = v[0]; // Глобальный максимум (пока что)
    int current_sum = v[0]; // Максимум, заканчивающийся *здесь*

    // Начинаем со второго элемента (i=1)
    for (size_t i = 1; i < v.size(); ++i) {
        // Что выгоднее: начать новый подмассив с v[i]
        // ИЛИ прибавить v[i] к старому?
        current_sum = max(v[i], current_sum + v[i]);
        
        // Не забываем обновить глобальный максимум
        max_sum = max(max_sum, current_sum);
    }

    cout << "Максимальная сумма непрерывного подмассива: " << max_sum << endl; // 6
    
    // Случай с одними отрицательными
    vector<int> v_neg = {-10, -5, -3, -20};
    // (Алгоритм корректно найдет -3)
    
    max_sum = v_neg[0];
    current_sum = v_neg[0];
    for (size_t i = 1; i < v_neg.size(); ++i) {
        current_sum = max(v_neg[i], current_sum + v_neg[i]);
        max_sum = max(max_sum, current_sum);
    }
    cout << "Максимум для {-10, -5, -3, -20}: " << max_sum << endl; // -3
    
    return 0;
}
```



